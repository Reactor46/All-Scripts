<#
.SYNOPSIS
    This script/function requests and receives a New Certificate from your Windows-based Issuing Certificate Authority.

    When used in conjunction with the Generate-CertTemplate.ps1 script/function, all needs can be satisfied.
    (See: https://github.com/pldmgg/misc-powershell/blob/master/Generate-CertTemplate.ps1)

    This can be run as a script by uncommenting the very last line calling the Generate-Certificate function, or by 
    simply loading the entire function into your current PowerShell shell and then calling it.

    IMPORTANT NOTE 1: By running the function without any parameters, the user will be walked through several prompts. 
    This is the recommended way to use this function until the user feels comfortable with parameters mentioned below.

.DESCRIPTION
    This function/script is split into the following sections (ctl-f to jump to each of these sections)
    - Libraries and Helper Functions (~Lines 298-1395)
    - Initial Variable Definition and Validation (~Lines 1397-1760)
    - Writing the Certificate Request Config File (~Lines 1762-2169)
    - Generate Certificate Request and Submit to Issuing Certificate Authority (~Lines 2172-2284)

    OUTPUTS
    All outputs are written to the $CertGenWorking directory specified by the user.

    ALWAYS GENERATED
    The following outputs are ALWAYS generated by this function/script, regardless of optional parameters: 
        - A Certificate Request Configuration File (with .inf file extension) - 
            RELEVANT PARAMETER: $CertificateRequestConfigFile
        - A Certificate Request File (with .csr file extenstion) - 
            RELEVANT PARAMETER: $CertificateRequestFile
        - A Public Certificate with the New Certificate Name (NewCertificate_$CertificateCN_[Timestamp].cer) - 
            RELEVANT PARAMETER: $CertFileOut
            NOTE: This file is not explicitly generated by the script. Rather, it is received from the Issuing Certificate Authority after 
            the Certificate Request is submitted and accepted by the Issuing Certificate Authority. 
            NOTE: If you choose to use Win32 OpenSSL to extract certs/keys from the .pfx file (see below), this file should have SIMILAR CONTENT
            to the file $PublicKeySansChainOutFile. To clarify, $PublicKeySansChainOutFile does NOT have what appear to be extraneous newlines, 
            but $CertFileOut DOES. Even though $CertFileOut has what appear to be extraneous newlines, Microsoft Crypto Shell Extensions will 
            be able to read both files as if they were the same. However, Linux machines will need to use $PublicKeySansChainOutFile (Also, the 
            file extension for $PublicKeySansChainOutFile can safely be changed from .cer to .pem without issue)
        - A Global HashTable called $GenerateCertificateFileOutputHashGlobal that can help the user quickly and easily reference output 
            files in $CertGenWorking. Example content of $GenerateCertificateFileOutputHashGlobal:

            Key   : CertificateRequestFile
            Value : NewCertRequest_aws-coreos3-client-server-cert04-Sep-2016_2127.csr
            Name  : CertificateRequestFile

            Key   : IntermediateCAPublicCertFile
            Value : ZeroSCA_Public_Cert.pem
            Name  : IntermediateCAPublicCertFile

            Key   : EndPointPublicCertFile
            Value : aws-coreos3-client-server-cert_Public_Cert.pem
            Name  : EndPointPublicCertFile

            Key   : AllPublicKeysInChainOut
            Value : NewCertificate_aws-coreos3-client-server-cert_all_public_keys_in_chain_.pem
            Name  : AllPublicKeysInChainOut

            Key   : CertificateRequestConfigFile
            Value : NewCertRequestConfig_aws-coreos3-client-server-cert04-Sep-2016_2127.inf
            Name  : CertificateRequestConfigFile

            Key   : EndPointUnProtectedPrivateKey
            Value : NewCertificate_aws-coreos3-client-server-cert_unprotected_private_key_.key
            Name  : EndPointUnProtectedPrivateKey

            Key   : RootCAPublicCertFile
            Value : ZeroDC01_Public_Cert.pem
            Name  : RootCAPublicCertFile

            Key   : CertADCSWebResponse
            Value : NewCertificate_aws-coreos3-client-server-cert_ADCSWebResponse04-Sep-2016_2127.txt
            Name  : CertADCSWebResponse

            Key   : CertFileOut
            Value : NewCertificate_aws-coreos3-client-server-cert04-Sep-2016_2127.cer
            Name  : CertFileOut

            Key   : PFXFileOut
            Value : NewCertificate_aws-coreos3-client-server-cert04-Sep-2016_2127.pfx
            Name  : PFXFileOut

            Key   : EndPointProtectedPrivateKey
            Value : NewCertificate_aws-coreos3-client-server-cert_protected_private_key_.pem
            Name  : EndPointProtectedPrivateKey

        - A Global HashTable called $CertNamevsContentsHashGlobal that contains the actual content of certain Certificates. 
            Example content of $CertNamevsContentsHashGlobal is as follows:

            Key   : EndPointUnProtectedPrivateKey
            Value : -----BEGIN RSA PRIVATE KEY-----
                    ...
                    -----END RSA PRIVATE KEY-----
            Name  : EndPointUnProtectedPrivateKey

            Key   : aws-coreos3-client-server-cert
            Value : -----BEGIN CERTIFICATE-----
                    ...
                    -----END CERTIFICATE-----
            Name  : aws-coreos3-client-server-cert

            Key   : ZeroSCA
            Value : -----BEGIN CERTIFICATE-----
                    ...
                    -----END CERTIFICATE-----
            Name  : ZeroSCA

            Key   : ZeroDC01
            Value : -----BEGIN CERTIFICATE-----
                    ...
                    -----END CERTIFICATE-----
            Name  : ZeroDC01

    
    GENERATED WHEN $MachineKeySet = "FALSE"
    The following outputs are ONLY generated by this function/script when $MachineKeySet = "FALSE" (this is its default setting)
        - A .pfx File Containing the Entire Public Certificate Chain AS WELL AS the Private Key of your New Certificate (with .pfx file extension) - 
            RELEVANT PARAMETER: $PFXFileOut
            NOTE: The Private Key must be marked as exportable in your Certificate Request Configuration File in order for the .pfx file to
            contain the private key. This is controlled by the parameter $PrivateKeyExportableValue = "TRUE". The Private Key is marked as 
            exportable by default.
    
    GENERATED WHEN $RequestViaWebEnrollment = "No"
    The following outputs are ONLY generated by this function/script when $RequestViaWebEnrollment = "No" (this is its default setting)
    (NOTE: Under this scenario, the workstation running the script must be part of the same domain as the Issuing Certificate Authority):
        - A Certificate Request Response File (with .rsp file extension) 
            NOTE: This file is not explicitly generated by the script. Rather, it is received from the Issuing Certificate Authority after 
            the Certificate Request is submitted
        - A Certificate Chain File (with .p7b file extension) -
            RELEVANT PARAMETER: $CertificateChainOut
            NOTE: This file is not explicitly generated by the script. Rather, it is received from the Issuing Certificate Authority after 
            the Certificate Request is submitted and accepted by the Issuing Certificate Authority
            NOTE: This file contains the entire chain of public certificates, from the requested certificate, up to the Root CA
            WARNING: In order to parse the public certificates for each entity up the chain, you MUST use the Crypto Shell Extensions GUI,
            otherwise, if you look at this content with a text editor, it appears as only one (1) public certificate.  Use the OpenSSL
            Certificate Chain File ($AllPublicKeysInChainOut) optional output in order to view a text file that parses each entity's public certificate.
    
    GENERATED WHEN $RequestViaWebEnrollment = "Yes"
    The following outputs are ONLY generated by this function/script when $RequestViaWebEnrollment = "Yes"
    (NOTE: Under this scenario, the workstation running the script is sending a web request to the ADCS Web Enrollment website):
        - An File Containing the HTTP Response From the ADCS Web Enrollment Site (with .txt file extension) - 
            RELEVANT PARAMETER: $CertADCSWebResponse
    
    GENERATED WHEN $UseOpenSSL = "Yes"
    The following outputs are ONLY generated by this function/script when $UseOpenSSL = "Yes"
    (WARNING: This creates a Dependency on a third party Win32 OpenSSL binary that can be found here: https://indy.fulgan.com/SSL/
    For more information, see the DEPENDENCIES Section below)
        - A Certificate Chain File (ending with "all_public_keys_in_chain.pem") -
            RELEVANT PARAMETER: $AllPublicKeysInChainOut
            NOTE: This optional parameter differs from the aforementioned .p7b certificate chain output in that it actually parses
            each entity's public certificate in a way that is viewable in a text editor.
        - EACH Public Certificate in the Certificate Chain File (file name like [Certificate CN]_Public_Cert.cer)
            - A Public Certificate with the New Certificate Name ($CertificateCN_Public_Cert.cer) -
                RELEVANT PARAMETER: $PublicKeySansChainOutFile
                NOTE: This file should have SIMILAR CONTENT to $CertFileOut referenced earlier. To clarify, $PublicKeySansChainOutFile does NOT have
                what appear to be extraneous newlines, but $CertFileOut DOES. Even though $CertFileOut has what appear to be extraneous newlines, Microsoft Crypto Shell Extensions will 
                be able to read both files as if they were the same. However, Linux machines will need to use $PublicKeySansChainOutFile (Also, the 
                file extension for $PublicKeySansChainOutFile can safely be changed from .cer to .pem without issue)
            - Additional Public Certificates in Chain including [Subordinate CA CN]_Public_Cert.cer and [Root CA CN]_Public_Cert.cer
        - A Password Protected Private Key file (ending with "protected_private_key.pem") -
            RELEVANT PARAMETER: $ProtectedPrivateKeyOut
            NOTE: This is the New Certificate's Private Key that is protected by a password defined by the $PFXPwdAsSecureString parameter.

    GENERATED WHEN $UseOpenSSL = "Yes" AND $StripPrivateKeyOfPassword = "Yes"
        - An Unprotected Private Key File (ends with unprotected_private_key.key) -
            RELEVANT PARAMETER: $UnProtectedPrivateKeyOut

    ALWAYS GENERATED


.PARAMETERS
    IMPORTANT NOTE 2: Default values for ALL parameters are already provided, and running the Generate-Certificate script/
    function will generate a New Certificate using these default values, however, the resulting Certificate
    may not satisfy all of your needs depending on your circumstances.

    Please review the explanation for each of the variables/parameters that can/should be changed below.

    1) $CertGenWorking - Full path to directory that all output files will be written to. Using a network location is fine, but 
    not recommended from a security standpoint.

    2) $BasisTemplate - Either the CN or the displayName of the Certificate Template that you are basing this New Certificate on.
    IMPORTANT NOTE: If you are requesting the new certificate via the ADCS Web Enrollment Website (i.e. $RequestViaWebEnrollment = "Yes") the Certificate Template will ONLY appear in the Certificate Template drop-down on the ADCS 
    Web Enrollment website (which makes it a valid option for this parameter) if msPKITemplateSchemaVersion is "2" or "1" AND 
    pKIExpirationPeriod is 1 year or LESS.  See the Generate-CertTemplate.ps1 script/function for more details here:
    https://github.com/pldmgg/misc-powershell/blob/master/Generate-CertTemplate.ps1

    3) $CertificateCN - The name that you would like to give the New Certificate. This name will appear in the following 
    locations:
        - "FriendlyName" field of the Certificate Request
        - "Friendly name" field the New Certificate itself
        - "Friendly Name" field when viewing the New Certificate in the Local Certificate Store
        - "Subject" field of the Certificate Request
        - "Subject" field on the New Certificate itself
        - "Issued To" field when viewing the New Certificate in the Local Certificate Store

    4) $CertificateRequestConfigFile - Certificate Request configuration file to be submitted to the Issuing Certificate 
    Authority. File extension is .inf.

    5) $CertificateRequestFile - Conversion of $CertificateRequestConfigFile via certreq to .csr file to be submitted to the 
    Issuing Certificate Authority. File extension is .csr.

    6) $CertFileOut - The New Public Certificate received from the Issuing Certificate Authority. File extension is .cer

    7) $CertificateChainOut - The Chain of Publiec Certificates from the New Public Certificate up to the Root Certificate 
    Authority. File extension is .p7b.

    # NOTE: File extension will be .p7b even if format is PKCS10 (which should have extension .p10). This is to ensure that 
    Microsoft Crypto Shell Extensions recognizes the file. (Some systems do not have .p10 associated with Crypto Shell Extensions 
    by default, leading to confusion). 

    8) $PFXFileOut - File containing both Public AND Private Keys for the New Certificate. File extension is .pfx

    9) $PFXPwdAsSecureString - A Plaintext Password OR a Secure String object. (Plaintext will be converted to a Secure String by the script).
    In order to export a .pfx file from the Local Certificate Store, a password must be supplied (or permissions based on user accounts 
    must be configured beforehand, but this is outside the scope of this script). 
    ***IMPORTANT*** This same password is applied to $ProtectedPrivateKeyOut if $UseOpenSSL = "Yes"
    ***IMPORTANT*** To avoid providing this password in plaintext on the command line, recommend using Generate-EncryptedPwdFile.ps1 and 
    Decrypt-EncryptedPwdFile.ps1 to pass this parameter. See:
    https://github.com/pldmgg/misc-powershell/blob/master/Generate-EncryptedPwdFile.ps1
    https://github.com/pldmgg/misc-powershell/blob/master/Decrypt-EncryptedPwdFile.ps1

    10) $RequestViaWebEnrollment - If this parameter is set to "No", then PowerShell cmdlets will be used that assume that the workstation 
    running this script is also joined to the same domain as the Issuing Certificate Authority. If this parameter is set to "Yes", then
    the Invoke-WebRequest will be used to POST data to the ADCS Web Enrollment website specified by $ADCSWebEnrollmentURL (see below).

    11) $ADCSWebEnrollmentURL - URL of ADCS Web Enrollment website. Example: https://pki.test.lab/certsrv

    12) $ADCSWebAuthType - The IIS Web Server hosting the ADCS Web Enrollment site can be configured to use Windows Authentication, Basic
    Authentication, or both. Specify either "Windows" or "Basic" for this parameter.

    13) $ADCSWebAuthUserName - A username with permission to access the ADCS Web Enrollment site. If $ADCSWebAuthType = "Basic", then
    INCLUDE the domain prefix as part of the username. Example: test2\testadmin . If $ADCSWebAuthType = "Windows", then DO NOT INCLUDE
    the domain prefix as part of the username. Example: testadmin
    (NOTE: If you mix up the above username formatting, then the script will figure it out. This is more of an FYI.)

    14) $ADCSWebAuthPass - A Plaintext Password OR a Secure String object. (Plaintext will be converted to a Secure String by the script).
    If this parameter is left blank, the user will be prompted for secure input. If using this script as part of a larger automated process, 
    use a wrapper function to pass this parameter securely (this is outside the scope of this script).
    ***IMPORTANT*** To avoid providing this password in plaintext on the command line, recommend using Generate-EncryptedPwdFile.ps1 and 
    Decrypt-EncryptedPwdFile.ps1 to pass this parameter. See:
    https://github.com/pldmgg/misc-powershell/blob/master/Generate-EncryptedPwdFile.ps1
    https://github.com/pldmgg/misc-powershell/blob/master/Decrypt-EncryptedPwdFile.ps1

    15) $CertADCSWebResponse - A file output that contains the HTTP response after submitting the Certificate Request via the ADCS Web
    Enrollment site.

    16) $Organization - Company Name. Will be added to "Subject" field.

    17) $OrganizationalUnit - Company Department. Will be added  to "Subject" field.

    18) $Locality - City. Will be added to "Subject" field.

    19) $State - State. Will be added to "Subject" field.

    20) $Country - Country. Will be added to "Subject" field.

    21) $KeyLengthOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough 
    that explains Key Length and asks the user for input.

    22) $KeyLength - See: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    23) $HashAlgorithmOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough 
    that explains Hash Algorithm values in this context and asks the user for input.

    24) $HashAlgorithmValue - See: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    25) $EncryptionAlgorithmOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive 
    walkthrough that explains Encryption Algorithm values in this context and asks the user for input.

    26) $EncryptionAlgorithmValue - See: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    27) $PrivateKeyExportableOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive prompt
    asking the user if they want to make the private key of the New Certificate exportable.

    28) $PrivateKeyExportableValue - Valid values are "TRUE" and "FALSE". Default value is "TRUE".

    29) $KeySpecOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough that 
    explains KeySpec values and asks the user for input.

    30) $KeySpecValue - Valid values are "1" and "2". See: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    31) $KeyUsageOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough that 
    explains KeyUsage values and asks the user for input.

    32) $KeyUsageValue - See: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    33) $MachineKeySet - Valid values are "TRUE" and "FALSE". Default value is "FALSE". If you would like the private key exported, use "FALSE". 
    If you are creating this certificate to be used in the User's security context (like for a developer to sign their code), enter "FALSE". 
    If you are using this certificate for a service that runs in the Computer's security context (such as a Web Server, Domain Controller, etc) and
    DO NOT need the Private Key exported use "TRUE".
    See: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    34) $SecureEmail - Valid values are "Yes" and "No". If the New Certificate is going to be used to digitally sign and/or encrypt emails, this parameter should be set to "Yes"

    35) $UserProtected - If $MachineKeySet is set to "TRUE", then $UserProtected MUST be set to "No". If $MachineKeySet is set
    to "FALSE", then $UserProtected can be set to "Yes" or "No". 

    If set to "Yes", a CryptoAPI password window is displayed when the key is generated during the certificate request 
    build process. You can optionally protect the key with a password in the window or choose to display only a window when the 
    key is used within an application. Once the key is protected with a password, you must enter this password every time the key 
    is accessed.

    WARNING: Do not set this parameter to "Yes" if you want this script/function to run unattended.

    36) $ProviderNameOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough that 
    explains Cryptographic Provider values and asks the user for input.

    37) $ProviderNameValuePrep - Name of the Cryptographic Provider you would like to use for the New Certificate.
    For more details, see: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    WARNING: The Certificate Template that this New Certificate is based on COULD POTENTIALLY limit the availble Crypographic 
    Provders for the Certificate Request.  Make sure the Cryptographic Provider you use is allowed by the Basis Certificate 
    Template

    38) $RequestTypeOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough that 
    explains RequestType values and asks the user for input.

    39) $RequestTypeValue - Indicates the format of the Certificate Request. Valid values are CMC, PKCS10, PKCS10-, and PKCS7.
    For more details, see: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx

    40) $IntendedPurposeOverride - Setting this parameter to "Yes", "Y", "yes", or "y" will trigger an interactive walkthrough 
    that explains IntendedPurpose values and asks the user for input.

    41) $IntendedPurposeValuesPrep - Valid values can be found in the array $ValidIntendedPurposeValues (use ctl+f to jump to 
    the array).  Example values are "Client Authentication" and "Code Signing".  This parameter takes a string of values separated by commas, or an array.

    ***IMPORTANT:*** If this parameter is not set by user, the IntendedPurposeValues of the Basis Certificate Template
    will be used.

    42) $UseOpenSSL - Valid values are "Yes" and "No".  Indicates whether the Win32 OpenSSL binary should be used to extract
    certificates/keys in a format readily used in Linux environments.

    43) $PathToWin32OpenSSL - Path to the Win32 OpenSSL binaries on your filesystem.
    Recommend using latest version from https://indy.fulgan.com/SSL/

    44) $AllPublicKeysInChainOut - File containing all public certificates in the chain, from the New Certificate up to the 
    Root Certificate Authority. File extension is .pem

    45) $PublicKeySansChainOutFile - File containing ONLY the Public Certificate of the New Certificate. File extension is .pem

    46) $ProtectedPrivateKeyOut - File containing the password-protected private key for the New Certificate. File extension is .pem

    47) $StripPrivateKeyOfPassword - Valid values are "Yes" and "No". Removes the password from $ProtectedPrivateKeyOut.

    48) $UnProtectedPrivateKeyOut - File containing the raw private key for the New Certificate. File extension is .key

    49) $AddSAN - Set this parameter to "Yes" if you intend to include Subject Alternate Names (SANs) on the New Certificate

    50) $TypesofSANObjectsToAdd - A comma separated list of SAN Object Types. All possible values are: DNS, Distinguished Name,
    URL, IP Address, Email, UPN, or GUID. 
    Example: DNS, IP Address, Email
    
    51) $DNSSANObjects - A comma separated list of DNS addresses.
    Example: www.fabrikam.com, www.contoso.com

    52) $DistinguishedNameSANObjects - A SEMI-COLON separated list of Distinguished Name objects.
    Example: CN=www01,OU=Web Servers,DC=fabrikam,DC=com; CN=www01,OU=Load Balancers,DC=fabrikam,DC=com

    53) $URLSANObjects - A comma separated list of URLs.
    Example: http://www.fabrikam.com, http://www.contoso.com

    54) $IPAddressSANObjects - A comma separated list of IP Addresses.
    Example: 172.31.10.13, 192.168.2.125

    55) $EmailSANObjects - A comma separated list of Email Addresses.
    Example: mike@fabrikam.com, hazem@fabrikam.com

    56) $UPNSANObjects - A comma separated list of Principal Name objects.
    Example: mike@fabrikam.com, hazem@fabrikam.com

    57) $GUIDSANObjects - A comma separated list of GUIDs.
    Example: f7c3ac41-b8ce-4fb4-aa58-3d1dc0e36b39, g8D4ac41-b8ce-4fb4-aa58-3d1dc0e47c48


.DEPENDENCIES
    OPTIONAL DEPENDENCIES
    1) RSAT (Windows Server Feature) - If $RequestViaWebEnrollment = "No", then the Get-ADObject cmdlet is used for various purposes. This cmdlet
    is available only if RSAT is installed on the Windows Server.

    2) Win32 OpenSSL - If $UseOpenSSL = "Yes", the script/function depends on the latest Win32 OpenSSL binary that can be found here:
    https://indy.fulgan.com/SSL/
    Simply extract the (32-bit) zip and place the directory on your filesystem in a location to be referenced by the parameter $PathToWin32OpenSSL.

    IMPORTANT NOTE 2: The above third-party Win32 OpenSSL binary is referenced by OpenSSL.org here:
    https://wiki.openssl.org/index.php/Binaries

.SAMPLE USAGE
    EXAMPLE 1: No Parameters Provided
    Generate-Certificate

    NOTE: Executing the script/function without any parameters will ask for input on de facto mandatory parameters.
    All other parameters will use default values which should be fine under the vast majority of circumstances.
    De facto mandatory parameters are as follows:
    -CertGenWorking
    -BasisTemplate
    -CertificateCN
    -Organization
    -OrganizationalUnit
    -Locality
    -State
    -Country
    -MachineKeySet
    -SecureEmail
    -UserProtected


    EXAMPLE 2: Minimal Parameters Provided
    Generate-Certificate `
    -CertGenWorking "C:\Users\zeroadmin\Desktop\CertGenWorking\test8" `
    -BasisTemplate "CertTempl166" `
    -CertificateCN "TigerSigningCert" `
    -Organization "Contoso Inc" `
    -OrganizationalUnit "DevOps Department" `
    -Locality "Portland" `
    -State "OR" `
    -Country "US" `
    -MachineKeySet "TRUE" `
    -SecureEmail "No" `
    -UserProtected "No" `
    

    EXAMPLE 3: Minimal Parameters Provided with Win32 OpenSSL
    Generate-Certificate `
    -CertGenWorking "C:\Users\zeroadmin\Desktop\CertGenWorking\test8" `
    -BasisTemplate "CertTempl166" `
    -CertificateCN "TigerSigningCert" `
    -PFXFileOut "TigerSigningCert.pfx" `
    -PFXPwdAsSecureString "ThisIsNotSecure987!" `
    -Organization "Contoso Inc" `
    -OrganizationalUnit "DevOps Department" `
    -Locality "Portland" `
    -State "OR" `
    -Country "US" `
    -MachineKeySet "FALSE" `
    -SecureEmail "No" `
    -UserProtected "No" `
    -UseOpenSSL "Yes" `
    -PathToWin32OpenSSL "C:\openssl-0.9.8r-i386-win32-rev2" `
    -AllPublicKeysInChainOut "TigerSigningCert_all_public_keys_in_chain.pem" `
    -PublicKeySansChainOutFile "TigerSigningCert_public_key_sans_chain.pem" `
    -ProtectedPrivateKeyOut "TigerSigningCert_protected_private_key.pem" `
    -UnProtectedPrivateKeyOut "TigerSigningCert_unprotected_private_key.key" `
    -StripPrivateKeyOfPassword "Yes"

    EXAMPLE 4: All Possible Parameters
    Generate-Certificate `
    -CertGenWorking "C:\Users\zeroadmin\Desktop\CertGenWorking\test8" `
    -BasisTemplate "CertTempl166" `
    -CertificateCN "TigerSigningCert" `
    -CertificateRequestConfigFile "TigerSigningCert.inf" `
    -CertificateRequestFile "TigerSigningCert.csr" `
    -CertFileOut "TigerSigningCert.cer" `
    -CertificateChainOut "TigerSigningCert.p7b" `
    -PFXFileOut "TigerSigningCert.pfx" `
    -PFXPwdAsSecureString "ThisIsNotSecure987!" `
    -RequestViaWebEnrollment "Yes" `
    -ADCSWebEnrollmentURL "https://pki.test2.lab/certsrv" `
    -ADCSWebAuthType "Windows" `
    -ADCSWebAuthUserName "testadmin" `
    -ADCSWebAuthPass "SecurityIsHard321!" `
    -CertADCSWebResponse "C:\Users\zeroadmin\Desktop\CertGenWorking\test8\ADCSWebResponse.txt"
    -Organization "Contoso Inc" `
    -OrganizationalUnit "DevOps Department" `
    -Locality "Portland" `
    -State "OR" `
    -Country "US" `
    -KeyLengthOverride "No" `
    -KeyLength "2048" `
    -HashAlgorithmOverride "No" `
    -HashAlgorithmValue "sha256" `
    -EncryptionAlgorithmOverride "No" `
    -EncryptionAlgorithmValue "AES" `
    -PrivateKeyExportableOverride "No" `
    -PrivateKeyExportableValue "TRUE" `
    -KeySpecOverride "No" `
    -KeySpecValue "1" `
    -KeyUsageOverride "No" `
    -KeyUsageValue "0x80" `
    -MachineKeySet "FALSE" `
    -SecureEmail "No" `
    -UserProtected "No" `
    -ProviderNameOverride "No" `
    -ProviderNameValuePrep "Microsoft Enhanced Cryptographic Provider v1.0" `
    -RequestTypeOverride "No" `
    -RequestTypeValue "PKCS10" `
    -IntendedPurposeOverride "No" `
    -IntendedPurposeValuesPrep "Code Signing, Document Signing" `
    -UseOpenSSL "Yes" `
    -PathToWin32OpenSSL "C:\openssl-0.9.8r-i386-win32-rev2" `
    -AllPublicKeysInChainOut "TigerSigningCert_all_public_keys_in_chain.pem" `
    -PublicKeySansChainOutFile "TigerSigningCert_public_key_sans_chain.pem" `
    -ProtectedPrivateKeyOut "TigerSigningCert_protected_private_key.pem" `
    -UnProtectedPrivateKeyOut "TigerSigningCert_unprotected_private_key.key" `
    -StripPrivateKeyOfPassword "Yes" `
    -AddSAN "Yes"
    -TypesofSANObjectsToAdd "DNS, Distinguished Name, URL, IP Address, UPN, GUID"
    -DNSSANObjects "www.fabrikam.com, www.contoso.org"
    -DistinguishedNameSANObjects "CN=www01,OU=Web Servers,DC=fabrikam,DC=com; CN=www01,OU=Load Balancers,DC=fabrikam,DC=com"
    -URLSANObjects "http://www.fabrikam.com, http://www.contoso.com"
    -IPAddressSANObjects "172.31.10.13, 192.168.2.125"
    -EmailSANObjects "mike@fabrikam.com, hazem@fabrikam.com"
    -UPNSANObjects "mike@fabrikam.com, hazem@fabrikam.com"
    -GUIDSANObjects "f7c3ac41-b8ce-4fb4-aa58-3d1dc0e36b39, g8D4ac41-b8ce-4fb4-aa58-3d1dc0e47c48"


#>

Function Generate-Certificate {
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$False)]
    $CertGenWorking = $(Read-Host -Prompt "Please enter a full path to a directory that the New Certificate will be saved to"),

    [Parameter(Mandatory=$False)]
    $BasisTemplate = $(Read-Host -Prompt "Please enter the name of an existing Certificate Template that you would like your New Certificate
    to be based on"),

    [Parameter(Mandatory=$False)]
    $CertificateCN = $(Read-Host -Prompt "Please enter the Name that you would like your Certificate to have
    For a Computer/Client/Server Certificate, recommend using host FQDN)"),

    [Parameter(Mandatory=$False)]
    $CertificateRequestConfigFile = "NewCertRequestConfig_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".inf",

    [Parameter(Mandatory=$False)]
    $CertificateRequestFile = "NewCertRequest_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".csr",

    [Parameter(Mandatory=$False)]
    $CertFileOut = "NewCertificate_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".cer",

    [Parameter(Mandatory=$False)]
    $CertificateChainOut = "NewCertificateChain_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".p7b",

    [Parameter(Mandatory=$False)]
    $PFXFileOut = "NewCertificate_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".pfx",

    [Parameter(Mandatory=$False)]
    $PFXPwdAsSecureString,

    # If the workstation being used to request the certificate is part of the same domain as the Issuing Certificate Authority, we can identify
    # the Issuing Certificate Authority with certutil, so there is no need to set an $IssuingCertificateAuth Parameter
    #[Parameter(Mandatory=$False)]
    #$IssuingCertAuth = $(Read-Host -Prompt "Please enter the FQDN the server responsible for Issuing New Certificates."),

    # If the workstation being used to request the certificate is NOT part of the same domain as the Issuing Certificate Authority, we must use
    # the ADCS WEb Enrollment site for the certificate request. $RequestViaWebEnrollment should be set to "Yes", and $ADCSWebEnrollmentURL should be set.
    [Parameter(Mandatory=$False)]
    $RequestViaWebEnrollment = "No",

    [Parameter(Mandatory=$False)]
    $ADCSWebEnrollmentURL,

    [Parameter(Mandatory=$False)]
    $ADCSWebAuthType,

    [Parameter(Mandatory=$False)]
    $ADCSWebAuthUserName,

    [Parameter(Mandatory=$False)]
    $ADCSWebAuthPass,

    [Parameter(Mandatory=$False)]
    $CertADCSWebResponse = "NewCertificate_$CertificateCN"+"_ADCSWebResponse"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".txt",

    [Parameter(Mandatory=$False)]
    $Organization = $(Read-Host -Prompt "Please enter the name of the the Company that will appear on the New Certificate"),

    [Parameter(Mandatory=$False)]
    $OrganizationalUnit = $(Read-Host -Prompt "Please enter the name of the Department that you work for within your Company"),

    [Parameter(Mandatory=$False)]
    $Locality = $(Read-Host -Prompt "Please enter the City where your Company is located"),

    [Parameter(Mandatory=$False)]
    $State = $(Read-Host -Prompt "Please enter the State where your Company is located"),

    [Parameter(Mandatory=$False)]
    $Country = $(Read-Host -Prompt "Please enter the Country where your Company is located"),

    <#
    # ValidityPeriod is controlled by the Certificate Template and cannot be modified at the time of certificate request
    # (Unless it is a special circumstance where "RequestType = Cert" resulting in a self-signed cert where no request
    # is actually submitted)
    [Parameter(Mandatory=$False)]
    $ValidityPeriodValue = $(Read-Host -Prompt "Please enter the length of time that the certificate will be valid for.
    NOTE: Values must be in Months or Years. For example '6 months' or '2 years'"),
    #>

    [Parameter(Mandatory=$False)]
    $KeyLengthOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeyLength = "2048",

    [Parameter(Mandatory=$False)]
    $HashAlgorithmOverride = "No",

    [Parameter(Mandatory=$False)]
    $HashAlgorithmValue = "sha256",

    <#
    # KeyAlgorithm should be determined by ProviderName. Run "certutil -csplist" to see which Providers use which Key Algorithms
    [Parameter(Mandatory=$False)]
    $KeyAlgorithmOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeyAlgorithmValue,
    #>

    [Parameter(Mandatory=$False)]
    $EncryptionAlgorithmOverride = "No",

    [Parameter(Mandatory=$False)]
    $EncryptionAlgorithmValue = "AES",

    [Parameter(Mandatory=$False)]
    $PrivateKeyExportableOverride = "No",

    [Parameter(Mandatory=$False)]
    $PrivateKeyExportableValue = "TRUE",

    [Parameter(Mandatory=$False)]
    $KeySpecOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeySpecValue = "1",

    [Parameter(Mandatory=$False)]
    $KeyUsageOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeyUsageValue = "0x80",
    
    [Parameter(Mandatory=$False)]
    $MachineKeySet = $(Read-Host -Prompt "If you would like the private key exported, please enter FALSE. If you are creating this certificate to be used
    in the User's security context (like for a developer to sign their code), enter FALSE. If you are using this certificate for a service 
    that runs in the Computer's security context (such as a Web Server, Domain Controller, etc) enter TRUE [TRUE/FALSE]"),

    [Parameter(Mandatory=$False)]
    $SecureEmail = $(Read-Host -Prompt "Are you using this new certificate for Secure E-Mail? [Yes/No]"),

    [Parameter(Mandatory=$False)]
    $UserProtected = $(Read-Host -Prompt "Would you like to password protect the keys on this certificate?
    WARNING: Password protecting the keys on this certificate will force the user to enter the 
    password *every time* the certificate is accessed! [Yes/No]"),

    [Parameter(Mandatory=$False)]
    $ProviderNameOverride = "No",

    [Parameter(Mandatory=$False)]
    $ProviderNameValuePrep = "Microsoft RSA SChannel Cryptographic Provider",

    [Parameter(Mandatory=$False)]
    $RequestTypeOverride = "No",

    [Parameter(Mandatory=$False)]
    $RequestTypeValue = "PKCS10",

    [Parameter(Mandatory=$False)]
    $IntendedPurposeOverride = "No",

    [Parameter(Mandatory=$False)]
    $IntendedPurposeValuesPrep,

    [Parameter(Mandatory=$False)]
    $UseOpenSSL = $(Read-Host -Prompt "Would you like to use Win32 OpenSSL to extract public cert and private key from the Microsoft .pfx file? [Yes/No]"),

    [Parameter(Mandatory=$False)]
    $PathToWin32OpenSSL = "C:\openssl-0.9.8r-i386-win32-rev2",

    [Parameter(Mandatory=$False)]
    $AllPublicKeysInChainOut = "NewCertificate_$CertificateCN"+"_all_public_keys_in_chain_"+".pem",

    [Parameter(Mandatory=$False)]
    $ProtectedPrivateKeyOut = "NewCertificate_$CertificateCN"+"_protected_private_key_"+".pem",
    
    [Parameter(Mandatory=$False)]
    $UnProtectedPrivateKeyOut = "NewCertificate_$CertificateCN"+"_unprotected_private_key_"+".key",

    [Parameter(Mandatory=$False)]
    $StripPrivateKeyOfPassword = "No",

    [Parameter(Mandatory=$False)]
    $AddSAN = "No",

    [Parameter(Mandatory=$False)]
    $TypesofSANObjectsToAdd,

    [Parameter(Mandatory=$False)]
    $DNSSANObjects,

    [Parameter(Mandatory=$False)]
    $DistinguishedNameSANObjects,

    [Parameter(Mandatory=$False)]
    $URLSANObjects,

    [Parameter(Mandatory=$False)]
    $IPAddressSANObjects,

    [Parameter(Mandatory=$False)]
    $UPNSANObjects,

    [Parameter(Mandatory=$False)]
    $GUIDSANObjects

)

##### BEGIN Libraries and Helper Functions #####

function Pause-ForWarning {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [int]$PauseTimeInSeconds = "10",

        [Parameter(Mandatory=$False)]
        $Message
    )

    Write-Host "WARNING: $Message"
    Write-Host "To HALT this script, press 'x' on your keyboard."
    Write-Host "To CONTINUE, press any key on your keyboard (except x, CTRL, ALT, Shift, or CapsLock), OR wait $PauseTimeInSeconds seconds"

    $timeout = New-Timespan -Seconds ($PauseTimeInSeconds - 1)
    $stopwatch = [diagnostics.stopwatch]::StartNew()
    while ($stopwatch.elapsed -lt $timeout){
        if ([Console]::KeyAvailable) {
            $keypressed = [Console]::ReadKey("NoEcho").Key
            Write-Host "You pressed the `"$keypressed`" key"
            if ($keypressed -eq "x") {
                Write-Host "Halting entire script with hard-stop!"
                Write-Error "Halting entire script with hard-stop!" 2>$null
                $global:FunctionResult = "0"
                exit 0
            }
            if ($keypressed -ne "x") {
                Write-Host "Continuing with rest of script..."
                break
            }
        }

        # Check once every 1 second to see if the above "if" condition is satisfied
        Start-Sleep 1
    }
    $global:FunctionResult = "0"
}

function Compare-Arrays {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [array]$LargerArray,

        [Parameter(Mandatory=$False)]
        [array]$SmallerArray
    )

    -not @($SmallerArray | where {$LargerArray -notcontains $_}).Count
}

function Convert-HexToDec {
    param($hex)

    ForEach ($value in $hex) {
        [Convert]::ToInt32($value,16)
    }
}

function Convert-DecToHex {
    param($dec)

    ForEach ($value in $dec) {
        "{0:x}" -f [Int]$value
    }
}

function Get-PermutationsAll {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        $array,

        [Parameter(Mandatory=$False)]
        $cur = "",

        [Parameter(Mandatory=$False)]
        $depth = 0,

        [Parameter(Mandatory=$False)]
        $list = @()
    )

    $depth ++
    for ($i = 0; $i -lt $array.Count; $i++)
    {
        $list += $cur+" "+$array[$i]

        if ($depth -lt $array.Count)
        {
            $list = Get-PermutationsAll $array ($cur+" "+$array[$i]) $depth $list
        }
    }

    $list

}

function Get-PermutationsNoRepeats {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        $array2,

        [Parameter(Mandatory=$False)]
        $cur2 = "",

        [Parameter(Mandatory=$False)]
        $depth2 = 0,

        [Parameter(Mandatory=$False)]
        $list2 = @()
    )

    $list2 = Get-PermutationsAll -array $array2 -cur $cur2 -depth $depth2 -list $list2

    $list3 = foreach ($obj1 in $list2) {
        [string]$obj2 = $obj1.Split(" ") | Sort-Object | Get-Unique
        $obj2
    }

    $list3 | Sort-Object | Get-Unique
}

# WARNING WARNING: DON'T USE Get-HexArraySumPossibilities funciton if you are trying to calculate all possible sums of MORE THAN five (5) numbers.
# It will freeze PowerShell.
function Get-HexArraySumPossibilities {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [array]$hexarray
    )

    # TODO: Validate $hexarray is values are separated by commas

    #$hexarray

    # Temporarily convert Hex to Decimal
    $hexarrayToDec = foreach ($obj1 in $hexarray) {
        Convert-HexToDec $obj1
    }
    #$hexarrayToDec

    $hexarrayToDecCombos = Get-PermutationsNoRepeats $hexarrayToDec
    [array]$hexarrayToDecCombosArray = ($hexarrayToDecCombos | %{$_.trim()}) -replace ' ',','
    #[array]$hexarrayToDecCombosArray
    

    $hexarrayDecCombosSummed = foreach ($obj1 in $hexarrayToDecCombosArray) {
        $obj2 = $obj1.Split(",")
        ($obj2 | Measure-Object -Sum).Sum
    }
    #$hexarrayDecCombosSummed

    $possibleHexSums = foreach ($obj1 in $hexarrayDecCombosSummed) {
        Convert-DecToHex $obj1
    }
    $possibleHexSums
}

$OIDHashTable = @{
    # Remote Desktop
    "Remote Desktop" = "1.3.6.1.4.1.311.54.1.2"
    # Windows Update
    "Windows Update" = "1.3.6.1.4.1.311.76.6.1"
    # Windows Third Party Applicaiton Component
    "Windows Third Party Application Component" = "1.3.6.1.4.1.311.10.3.25"
    # Windows TCB Component
    "Windows TCB Component" = "1.3.6.1.4.1.311.10.3.23"
    # Windows Store
    "Windows Store" = "1.3.6.1.4.1.311.76.3.1"
    # Windows Software Extension verification
    " Windows Software Extension Verification" = "1.3.6.1.4.1.311.10.3.26"
    # Windows RT Verification
    "Windows RT Verification" = "1.3.6.1.4.1.311.10.3.21"
    # Windows Kits Component
    "Windows Kits Component" = "1.3.6.1.4.1.311.10.3.20"
    # ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL
    "No OCSP Failover to CRL" = "1.3.6.1.4.1.311.60.3.3"
    # ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION
    "Auto Update End Revocation" = "1.3.6.1.4.1.311.60.3.2"
    # ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION
    "Auto Update CA Revocation" = "1.3.6.1.4.1.311.60.3.1"
    # Revoked List Signer
    "Revoked List Signer" = "1.3.6.1.4.1.311.10.3.19"
    # Protected Process Verification
    "Protected Process Verification" = "1.3.6.1.4.1.311.10.3.24"
    # Protected Process Light Verification
    "Protected Process Light Verification" = "1.3.6.1.4.1.311.10.3.22"
    # Platform Certificate
    "Platform Certificate" = "2.23.133.8.2"
    # Microsoft Publisher
    "Microsoft Publisher" = "1.3.6.1.4.1.311.76.8.1"
    # Kernel Mode Code Signing
    "Kernel Mode Code Signing" = "1.3.6.1.4.1.311.6.1.1"
    # HAL Extension
    "HAL Extension" = "1.3.6.1.4.1.311.61.5.1"
    # Endorsement Key Certificate
    "Endorsement Key Certificate" = "2.23.133.8.1"
    # Early Launch Antimalware Driver
    "Early Launch Antimalware Driver" = "1.3.6.1.4.1.311.61.4.1"
    # Dynamic Code Generator
    "Dynamic Code Generator" = "1.3.6.1.4.1.311.76.5.1"
    # Domain Name System (DNS) Server Trust
    "DNS Server Trust" = "1.3.6.1.4.1.311.64.1.1"
    # Document Encryption
    "Document Encryption" = "1.3.6.1.4.1.311.80.1"
    # Disallowed List
    "Disallowed List" = "1.3.6.1.4.1.10.3.30"
    # Attestation Identity Key Certificate
    "Attestation Identity Key Certificate" = "2.23.133.8.3"
	"Generic Conference Contro" = "0.0.20.124.0.1"
	"X509Extensions" = "1.3.6.1.4.1.311.2.1.14"
	"EnrollmentCspProvider" = "1.3.6.1.4.1.311.13.2.2"
    # System Health Authentication
	"System Health Authentication" = "1.3.6.1.4.1.311.47.1.1"
	"OsVersion" = "1.3.6.1.4.1.311.13.2.3"
	"RenewalCertificate" = "1.3.6.1.4.1.311.13.1"
	"Certificate Template" = "1.3.6.1.4.1.311.20.2"
	"RequestClientInfo" = "1.3.6.1.4.1.311.21.20"
	"ArchivedKeyAttr" = "1.3.6.1.4.1.311.21.13"
	"EncryptedKeyHash" = "1.3.6.1.4.1.311.21.21"
	"EnrollmentNameValuePair" = "1.3.6.1.4.1.311.13.2.1"
	"IdAtName" = "2.5.4.41"
	"IdAtCommonName" = "2.5.4.3"
	"IdAtLocalityName" = "2.5.4.7"
	"IdAtStateOrProvinceName" = "2.5.4.8"
	"IdAtOrganizationName" = "2.5.4.10"
	"IdAtOrganizationalUnitName" = "2.5.4.11"
	"IdAtTitle" = "2.5.4.12"
	"IdAtDnQualifier" = "2.5.4.46"
	"IdAtCountryName" = "2.5.4.6"
	"IdAtSerialNumber" = "2.5.4.5"
	"IdAtPseudonym" = "2.5.4.65"
	"IdDomainComponent" = "0.9.2342.19200300.100.1.25"
	"IdEmailAddress" = "1.2.840.113549.1.9.1"
	"IdCeAuthorityKeyIdentifier" = "2.5.29.35"
	"IdCeSubjectKeyIdentifier" = "2.5.29.14"
	"IdCeKeyUsage" = "2.5.29.15"
	"IdCePrivateKeyUsagePeriod" = "2.5.29.16"
	"IdCeCertificatePolicies" = "2.5.29.32"
	"IdCePolicyMappings" = "2.5.29.33"
	"IdCeSubjectAltName" = "2.5.29.17"
	"IdCeIssuerAltName" = "2.5.29.18"
	"IdCeBasicConstraints" = "2.5.29.19"
	"IdCeNameConstraints" = "2.5.29.30"
	"idCdPolicyConstraints" = "2.5.29.36"
	"IdCeExtKeyUsage" = "2.5.29.37"
	"IdCeCRLDistributionPoints" = "2.5.29.31"
	"IdCeInhibitAnyPolicy" = "2.5.29.54"
	"IdPeAuthorityInfoAccess" = "1.3.6.1.5.5.7.1.1"
	"IdPeSubjectInfoAccess" = "1.3.6.1.5.5.7.1.11"
	"IdCeCRLNumber" = "2.5.29.20"
	"IdCeDeltaCRLIndicator" = "2.5.29.27"
	"IdCeIssuingDistributionPoint" = "2.5.29.28"
	"IdCeFreshestCRL" = "2.5.29.46"
	"IdCeCRLReason" = "2.5.29.21"
	"IdCeHoldInstructionCode" = "2.5.29.23"
	"IdCeInvalidityDate" = "2.5.29.24"
	"IdCeCertificateIssuer" = "2.5.29.29"
	"IdModAttributeCert" = "1.3.6.1.5.5.7.0.12"
	"IdPeAcAuditIdentity" = "1.3.6.1.5.5.7.1.4"
	"IdCeTargetInformation" = "2.5.29.55"
	"IdCeNoRevAvail" = "2.5.29.56"
	"IdAcaAuthenticationInfo" = "1.3.6.1.5.5.7.10.1"
	"IdAcaAccessIdentity" = "1.3.6.1.5.5.7.10.2"
	"IdAcaChargingIdentity" = "1.3.6.1.5.5.7.10.3"
	"IdAcaGroup" = "1.3.6.1.5.5.7.10.4"
	"IdAtRole" = "2.5.4.72"
	"IdAtClearance" = "2.5.1.5.55"
	"IdAcaEncAttrs" = "1.3.6.1.5.5.7.10.6"
	"IdPeAcProxying" = "1.3.6.1.5.5.7.1.10"
	"IdPeAaControls" = "1.3.6.1.5.5.7.1.6"
	"IdCtContentInfo" = "1.2.840.113549.1.9.16.1.6"
	"IdDataAuthpack" = "1.2.840.113549.1.7.1"
	"IdSignedData" = "1.2.840.113549.1.7.2"
	"IdEnvelopedData" = "1.2.840.113549.1.7.3"
	"IdDigestedData" = "1.2.840.113549.1.7.5"
	"IdEncryptedData" = "1.2.840.113549.1.7.6"
	"IdCtAuthData" = "1.2.840.113549.1.9.16.1.2"
	"IdContentType" = "1.2.840.113549.1.9.3"
	"IdMessageDigest" = "1.2.840.113549.1.9.4"
	"IdSigningTime" = "1.2.840.113549.1.9.5"
	"IdCounterSignature" = "1.2.840.113549.1.9.6"
	"RsaEncryption" = "1.2.840.113549.1.1.1"
	"IdRsaesOaep" = "1.2.840.113549.1.1.7"
	"IdPSpecified" = "1.2.840.113549.1.1.9"
	"IdRsassaPss" = "1.2.840.113549.1.1.10"
	"Md2WithRSAEncryption" = "1.2.840.113549.1.1.2"
	"Md5WithRSAEncryption" = "1.2.840.113549.1.1.4"
	"Sha1WithRSAEncryption" = "1.2.840.113549.1.1.5"
	"Sha256WithRSAEncryption" = "1.2.840.113549.1.1.11"
	"Sha384WithRSAEncryption" = "1.2.840.113549.1.1.12"
	"Sha512WithRSAEncryption" = "1.2.840.113549.1.1.13"
	"IdMd2" = "1.2.840.113549.2.2"
	"IdMd5" = "1.2.840.113549.2.5"
	"IdSha1" = "1.3.14.3.2.26"
	"IdSha256" = "2.16.840.1.101.3.4.2.1"
	"IdSha384" = "2.16.840.1.101.3.4.2.2"
	"IdSha512" = "2.16.840.1.101.3.4.2.3"
	"IdMgf1" = "1.2.840.113549.1.1.8"
	"IdDsaWithSha1" = "1.2.840.10040.4.3"
	"EcdsaWithSHA1" = "1.2.840.10045.4.1"
	"IdDsa" = "1.2.840.10040.4.1"
	"DhPublicNumber" = "1.2.840.10046.2.1"
	"IdKeyExchangeAlgorithm" = "2.16.840.1.101.2.1.1.22"
	"IdEcPublicKey" = "1.2.840.10045.2.1"
	"PrimeField" = "1.2.840.10045.1.1"
	"CharacteristicTwoField" = "1.2.840.10045.1.2"
	"GnBasis" = "1.2.840.10045.1.2.1.1"
	"TpBasis" = "1.2.840.10045.1.2.1.2"
	"PpBasis" = "1.2.840.10045.1.2.1.3"
	"IdAlgEsdh" = "1.2.840.113549.1.9.16.3.5"
	"IdAlgSsdh" = "1.2.840.113549.1.9.16.3.10"
	"IdAlgCms3DesWrap" = "1.2.840.113549.1.9.16.3.6"
	"IdAlgCmsRc2Wrap" = "1.2.840.113549.1.9.16.3.7"
	"IdPbkDf2" = "1.2.840.113549.1.5.12"
	"DesEde3Cbc" = "1.2.840.113549.3.7"
	"Rc2Cbc" = "1.2.840.113549.3.2"
	"HmacSha1" = "1.3.6.1.5.5.8.1.2"
	"IdAes128Cbc" = "2.16.840.1.101.3.4.1.2"
	"IdAes192Cbc" = "2.16.840.1.101.3.4.1.22"
	"IdAes256Cbc" = "2.16.840.1.101.3.4.1.42"
	"IdAes128Wrap" = "2.16.840.1.101.3.4.1.5"
	"IdAes192Wrap" = "2.16.840.1.101.3.4.1.25"
	"IdAes256Wrap" = "2.16.840.1.101.3.4.1.45"
	"IdCmcIdentification" = "1.3.6.1.5.5.7.7.2"
	"IdCmcIdentityProof" = "1.3.6.1.5.5.7.7.3"
	"IdCmcDataReturn" = "1.3.6.1.5.5.7.7.4"
	"IdCmcTransactionId" = "1.3.6.1.5.5.7.7.5"
	"IdCmcSenderNonce" = "1.3.6.1.5.5.7.7.6"
	"IdCmcRecipientNonce" = "1.3.6.1.5.5.7.7.7"
	"IdCmcRegInfo" = "1.3.6.1.5.5.7.7.18"
	"IdCmcResponseInfo" = "1.3.6.1.5.5.7.7.19"
	"IdCmcQueryPending" = "1.3.6.1.5.5.7.7.21"
	"IdCmcPopLinkRandom" = "1.3.6.1.5.5.7.7.22"
	"IdCmcPopLinkWitness" = "1.3.6.1.5.5.7.7.23"
	"IdCctPKIData" = "1.3.6.1.5.5.7.12.2"
	"IdCctPKIResponse" = "1.3.6.1.5.5.7.12.3"
	"IdCmccMCStatusInfo" = "1.3.6.1.5.5.7.7.1"
	"IdCmcAddExtensions" = "1.3.6.1.5.5.7.7.8"
	"IdCmcEncryptedPop" = "1.3.6.1.5.5.7.7.9"
	"IdCmcDecryptedPop" = "1.3.6.1.5.5.7.7.10"
	"IdCmcLraPopWitness" = "1.3.6.1.5.5.7.7.11"
	"IdCmcGetCert" = "1.3.6.1.5.5.7.7.15"
	"IdCmcGetCRL" = "1.3.6.1.5.5.7.7.16"
	"IdCmcRevokeRequest" = "1.3.6.1.5.5.7.7.17"
	"IdCmcConfirmCertAcceptance" = "1.3.6.1.5.5.7.7.24"
	"IdExtensionReq" = "1.2.840.113549.1.9.14"
	"IdAlgNoSignature" = "1.3.6.1.5.5.7.6.2"
	"PasswordBasedMac" = "1.2.840.113533.7.66.13"
	"IdRegCtrlRegToken" = "1.3.6.1.5.5.7.5.1.1"
	"IdRegCtrlAuthenticator" = "1.3.6.1.5.5.7.5.1.2"
	"IdRegCtrlPkiPublicationInfo" = "1.3.6.1.5.5.7.5.1.3"
	"IdRegCtrlPkiArchiveOptions" = "1.3.6.1.5.5.7.5.1.4"
	"IdRegCtrlOldCertID" = "1.3.6.1.5.5.7.5.1.5"
	"IdRegCtrlProtocolEncrKey" = "1.3.6.1.5.5.7.5.1.6"
	"IdRegInfoUtf8Pairs" = "1.3.6.1.5.5.7.5.2.1"
	"IdRegInfoCertReq" = "1.3.6.1.5.5.7.5.2.2"
	"SpnegoToken" = "1.3.6.1.5.5.2"
	"SpnegoNegTok" = "1.3.6.1.5.5.2.4.2"
	"GSS_KRB5_NT_USER_NAME" = "1.2.840.113554.1.2.1.1"
	"GSS_KRB5_NT_MACHINE_UID_NAME" = "1.2.840.113554.1.2.1.2"
	"GSS_KRB5_NT_STRING_UID_NAME" = "1.2.840.113554.1.2.1.3"
	"GSS_C_NT_HOSTBASED_SERVICE" = "1.2.840.113554.1.2.1.4"
	"KerberosToken" = "1.2.840.113554.1.2.2"
	"Negoex" = "1.3.6.1.4.1.311.2.2.30" 
	"GSS_KRB5_NT_PRINCIPAL_NAME" = "1.2.840.113554.1.2.2.1"
	"GSS_KRB5_NT_PRINCIPAL" = "1.2.840.113554.1.2.2.2"
	"UserToUserMechanism" = "1.2.840.113554.1.2.2.3"
	"MsKerberosToken" = "1.2.840.48018.1.2.2"
	"NLMP" = "1.3.6.1.4.1.311.2.2.10"
	"IdPkixOcspBasic" = "1.3.6.1.5.5.7.48.1.1"
	"IdPkixOcspNonce" = "1.3.6.1.5.5.7.48.1.2"
	"IdPkixOcspCrl" = "1.3.6.1.5.5.7.48.1.3"
	"IdPkixOcspResponse" = "1.3.6.1.5.5.7.48.1.4"
	"IdPkixOcspNocheck" = "1.3.6.1.5.5.7.48.1.5"
	"IdPkixOcspArchiveCutoff" = "1.3.6.1.5.5.7.48.1.6"
	"IdPkixOcspServiceLocator" = "1.3.6.1.5.5.7.48.1.7"
    # Smartcard Logon
	"IdMsKpScLogon" = "1.3.6.1.4.1.311.20.2.2"
	"IdPkinitSan" = "1.3.6.1.5.2.2"
	"IdPkinitAuthData" = "1.3.6.1.5.2.3.1"
	"IdPkinitDHKeyData" = "1.3.6.1.5.2.3.2"
	"IdPkinitRkeyData" = "1.3.6.1.5.2.3.3"
	"IdPkinitKPClientAuth" = "1.3.6.1.5.2.3.4"
	"IdPkinitKPKdc" = "1.3.6.1.5.2.3.5"
	"SHA1 with RSA signature" = "1.3.14.3.2.29"
	"AUTHORITY_KEY_IDENTIFIER" = "2.5.29.1"
	"KEY_ATTRIBUTES" = "2.5.29.2"
	"CERT_POLICIES_95" = "2.5.29.3"
	"KEY_USAGE_RESTRICTION" = "2.5.29.4"
	"SUBJECT_ALT_NAME" = "2.5.29.7"
	"ISSUER_ALT_NAME" = "2.5.29.8"
	"Subject_Directory_Attributes" = "2.5.29.9"
	"BASIC_CONSTRAINTS" = "2.5.29.10"
	"ANY_CERT_POLICY" = "2.5.29.32.0"
	"LEGACY_POLICY_MAPPINGS" = "2.5.29.5"
    # Certificate Request Agent
	"ENROLLMENT_AGENT" = "1.3.6.1.4.1.311.20.2.1"
	"PKIX" = "1.3.6.1.5.5.7"
	"PKIX_PE" = "1.3.6.1.5.5.7.1"
	"NEXT_UPDATE_LOCATION" = "1.3.6.1.4.1.311.10.2"
	"REMOVE_CERTIFICATE" = "1.3.6.1.4.1.311.10.8.1"
	"CROSS_CERT_DIST_POINTS" = "1.3.6.1.4.1.311.10.9.1"
	"CTL" = "1.3.6.1.4.1.311.10.1"
	"SORTED_CTL" = "1.3.6.1.4.1.311.10.1.1"
	"SERIALIZED" = "1.3.6.1.4.1.311.10.3.3.1"
	"NT_PRINCIPAL_NAME" = "1.3.6.1.4.1.311.20.2.3"
	"PRODUCT_UPDATE" = "1.3.6.1.4.1.311.31.1"
	"ANY_APPLICATION_POLICY" = "1.3.6.1.4.1.311.10.12.1"
    # CTL Usage
	"AUTO_ENROLL_CTL_USAGE" = "1.3.6.1.4.1.311.20.1"
	"CERT_MANIFOLD" = "1.3.6.1.4.1.311.20.3"
	"CERTSRV_CA_VERSION" = "1.3.6.1.4.1.311.21.1"
	"CERTSRV_PREVIOUS_CERT_HASH" = "1.3.6.1.4.1.311.21.2"
	"CRL_VIRTUAL_BASE" = "1.3.6.1.4.1.311.21.3"
	"CRL_NEXT_PUBLISH" = "1.3.6.1.4.1.311.21.4"
    # Private Key Archival
	"KP_CA_EXCHANGE" = "1.3.6.1.4.1.311.21.5"
    # Key Recovery Agent
	"KP_KEY_RECOVERY_AGENT" = "1.3.6.1.4.1.311.21.6"
	"CERTIFICATE_TEMPLATE" = "1.3.6.1.4.1.311.21.7"
	"ENTERPRISE_OID_ROOT" = "1.3.6.1.4.1.311.21.8"
	"RDN_DUMMY_SIGNER" = "1.3.6.1.4.1.311.21.9"
	"APPLICATION_CERT_POLICIES" = "1.3.6.1.4.1.311.21.10"
	"APPLICATION_POLICY_MAPPINGS" = "1.3.6.1.4.1.311.21.11"
	"APPLICATION_POLICY_CONSTRAINTS" = "1.3.6.1.4.1.311.21.12"
	"CRL_SELF_CDP" = "1.3.6.1.4.1.311.21.14"
	"REQUIRE_CERT_CHAIN_POLICY" = "1.3.6.1.4.1.311.21.15"
	"ARCHIVED_KEY_CERT_HASH" = "1.3.6.1.4.1.311.21.16"
	"ISSUED_CERT_HASH" = "1.3.6.1.4.1.311.21.17"
	"DS_EMAIL_REPLICATION" = "1.3.6.1.4.1.311.21.19"
	"CERTSRV_CROSSCA_VERSION" = "1.3.6.1.4.1.311.21.22"
	"NTDS_REPLICATION" = "1.3.6.1.4.1.311.25.1"
	"PKIX_KP" = "1.3.6.1.5.5.7.3"
	"PKIX_KP_SERVER_AUTH" = "1.3.6.1.5.5.7.3.1"
	"PKIX_KP_CLIENT_AUTH" = "1.3.6.1.5.5.7.3.2"
	"PKIX_KP_CODE_SIGNING" = "1.3.6.1.5.5.7.3.3"
    # Secure Email
	"PKIX_KP_EMAIL_PROTECTION" = "1.3.6.1.5.5.7.3.4"
    # IP Security End System
	"PKIX_KP_IPSEC_END_SYSTEM" = "1.3.6.1.5.5.7.3.5"
    # IP Security Tunnel Termination
	"PKIX_KP_IPSEC_TUNNEL" = "1.3.6.1.5.5.7.3.6"
    # IP Security User
	"PKIX_KP_IPSEC_USER" = "1.3.6.1.5.5.7.3.7"
    # Time Stamping
	"PKIX_KP_TIMESTAMP_SIGNING" = "1.3.6.1.5.5.7.3.8"
    "KP_OCSP_SIGNING" = "1.3.6.1.5.5.7.3.9"
    # IP security IKE intermediate
	"IPSEC_KP_IKE_INTERMEDIATE" = "1.3.6.1.5.5.8.2.2"
    # Microsoft Trust List Signing
	"KP_CTL_USAGE_SIGNING" = "1.3.6.1.4.1.311.10.3.1"
    # Microsoft Time Stamping
	"KP_TIME_STAMP_SIGNING" = "1.3.6.1.4.1.311.10.3.2"
	"SERVER_GATED_CRYPTO" = "1.3.6.1.4.1.311.10.3.3"
	"SGC_NETSCAPE" = "2.16.840.1.113730.4.1"
	"KP_EFS" = "1.3.6.1.4.1.311.10.3.4"
	"EFS_RECOVERY" = "1.3.6.1.4.1.311.10.3.4.1"
    # Windows Hardware Driver Verification
	"WHQL_CRYPTO" = "1.3.6.1.4.1.311.10.3.5"
    # Windows System Component Verification
	"NT5_CRYPTO" = "1.3.6.1.4.1.311.10.3.6"
    # OEM Windows System Component Verification
	"OEM_WHQL_CRYPTO" = "1.3.6.1.4.1.311.10.3.7"
    # Embedded Windows System Component Verification
	"EMBEDDED_NT_CRYPTO" = "1.3.6.1.4.1.311.10.3.8"
    # Root List Signer
	"ROOT_LIST_SIGNER" = "1.3.6.1.4.1.311.10.3.9"
    # Qualified Subordination
	"KP_QUALIFIED_SUBORDINATION" = "1.3.6.1.4.1.311.10.3.10"
    # Key Recovery
	"KP_KEY_RECOVERY" = "1.3.6.1.4.1.311.10.3.11"
	"KP_DOCUMENT_SIGNING" = "1.3.6.1.4.1.311.10.3.12"
    # Lifetime Signing
	"KP_LIFETIME_SIGNING" = "1.3.6.1.4.1.311.10.3.13"
	"KP_MOBILE_DEVICE_SOFTWARE" = "1.3.6.1.4.1.311.10.3.14"
	# Digital Rights
    "DRM" = "1.3.6.1.4.1.311.10.5.1"
	"DRM_INDIVIDUALIZATION" = "1.3.6.1.4.1.311.10.5.2"
    # Key Pack Licenses
	"LICENSES" = "1.3.6.1.4.1.311.10.6.1"
    # License Server Verification
	"LICENSE_SERVER" = "1.3.6.1.4.1.311.10.6.2"
	"YESNO_TRUST_ATTR" = "1.3.6.1.4.1.311.10.4.1"
	"PKIX_POLICY_QUALIFIER_CPS" = "1.3.6.1.5.5.7.2.1"
	"PKIX_POLICY_QUALIFIER_USERNOTICE" = "1.3.6.1.5.5.7.2.2"
	"CERT_POLICIES_95_QUALIFIER1" = "2.16.840.1.113733.1.7.1.1"
	"RSA" = "1.2.840.113549"
	"PKCS" = "1.2.840.113549.1"
	"RSA_HASH" = "1.2.840.113549.2"
	"RSA_ENCRYPT" = "1.2.840.113549.3"
	"PKCS_1" = "1.2.840.113549.1.1"
	"PKCS_2" = "1.2.840.113549.1.2"
	"PKCS_3" = "1.2.840.113549.1.3"
	"PKCS_4" = "1.2.840.113549.1.4"
	"PKCS_5" = "1.2.840.113549.1.5"
	"PKCS_6" = "1.2.840.113549.1.6"
	"PKCS_7" = "1.2.840.113549.1.7"
	"PKCS_8" = "1.2.840.113549.1.8"
	"PKCS_9" = "1.2.840.113549.1.9"
	"PKCS_10" = "1.2.840.113549.1.10"
	"PKCS_12" = "1.2.840.113549.1.12"
	"RSA_MD4RSA" = "1.2.840.113549.1.1.3"
	"RSA_SETOAEP_RSA" = "1.2.840.113549.1.1.6"
	"RSA_DH" = "1.2.840.113549.1.3.1"
	"RSA_signEnvData" = "1.2.840.113549.1.7.4"
	"RSA_unstructName" = "1.2.840.113549.1.9.2"
	"RSA_challengePwd" = "1.2.840.113549.1.9.7"
	"RSA_unstructAddr" = "1.2.840.113549.1.9.8"
	"RSA_extCertAttrs" = "1.2.840.113549.1.9.9"
	"RSA_SMIMECapabilities" = "1.2.840.113549.1.9.15"
	"RSA_preferSignedData" = "1.2.840.113549.1.9.15.1"
	"RSA_SMIMEalg" = "1.2.840.113549.1.9.16.3"
	"RSA_MD4" = "1.2.840.113549.2.4"
	"RSA_RC4" = "1.2.840.113549.3.4"
	"RSA_RC5_CBCPad" = "1.2.840.113549.3.9"
	"ANSI_X942" = "1.2.840.10046"
	"X957" = "1.2.840.10040"
	"DS" = "2.5"
	"DSALG" = "2.5.8"
	"DSALG_CRPT" = "2.5.8.1"
	"DSALG_HASH" = "2.5.8.2"
	"DSALG_SIGN" = "2.5.8.3"
	"DSALG_RSA" = "2.5.8.1.1"
	"OIW" = "1.3.14"
	"OIWSEC" = "1.3.14.3.2"
	"OIWSEC_md4RSA" = "1.3.14.3.2.2"
	"OIWSEC_md5RSA" = "1.3.14.3.2.3"
	"OIWSEC_md4RSA2" = "1.3.14.3.2.4"
	"OIWSEC_desECB" = "1.3.14.3.2.6"
	"OIWSEC_desCBC" = "1.3.14.3.2.7"
	"OIWSEC_desOFB" = "1.3.14.3.2.8"
	"OIWSEC_desCFB" = "1.3.14.3.2.9"
	"OIWSEC_desMAC" = "1.3.14.3.2.10"
	"OIWSEC_rsaSign" = "1.3.14.3.2.11"
	"OIWSEC_dsa" = "1.3.14.3.2.12"
	"OIWSEC_shaDSA" = "1.3.14.3.2.13"
	"OIWSEC_mdc2RSA" = "1.3.14.3.2.14"
	"OIWSEC_shaRSA" = "1.3.14.3.2.15"
	"OIWSEC_dhCommMod" = "1.3.14.3.2.16"
	"OIWSEC_desEDE" = "1.3.14.3.2.17"
	"OIWSEC_sha" = "1.3.14.3.2.18"
	"OIWSEC_mdc2" = "1.3.14.3.2.19"
	"OIWSEC_dsaComm" = "1.3.14.3.2.20"
	"OIWSEC_dsaCommSHA" = "1.3.14.3.2.21"
	"OIWSEC_rsaXchg" = "1.3.14.3.2.22"
	"OIWSEC_keyHashSeal" = "1.3.14.3.2.23"
	"OIWSEC_md2RSASign" = "1.3.14.3.2.24"
	"OIWSEC_md5RSASign" = "1.3.14.3.2.25"
	"OIWSEC_dsaSHA1" = "1.3.14.3.2.27"
	"OIWSEC_dsaCommSHA1" = "1.3.14.3.2.28"
	"OIWDIR" = "1.3.14.7.2"
	"OIWDIR_CRPT" = "1.3.14.7.2.1"
	"OIWDIR_HASH" = "1.3.14.7.2.2"
	"OIWDIR_SIGN" = "1.3.14.7.2.3"
	"OIWDIR_md2" = "1.3.14.7.2.2.1"
	"OIWDIR_md2RSA" = "1.3.14.7.2.3.1"
	"INFOSEC" = "2.16.840.1.101.2.1"
	"INFOSEC_sdnsSignature" = "2.16.840.1.101.2.1.1.1"
	"INFOSEC_mosaicSignature" = "2.16.840.1.101.2.1.1.2"
	"INFOSEC_sdnsConfidentiality" = "2.16.840.1.101.2.1.1.3"
	"INFOSEC_mosaicConfidentiality" = "2.16.840.1.101.2.1.1.4"
	"INFOSEC_sdnsIntegrity" = "2.16.840.1.101.2.1.1.5"
	"INFOSEC_mosaicIntegrity" = "2.16.840.1.101.2.1.1.6"
	"INFOSEC_sdnsTokenProtection" = "2.16.840.1.101.2.1.1.7"
	"INFOSEC_mosaicTokenProtection" = "2.16.840.1.101.2.1.1.8"
	"INFOSEC_sdnsKeyManagement" = "2.16.840.1.101.2.1.1.9"
	"INFOSEC_mosaicKeyManagement" = "2.16.840.1.101.2.1.1.10"
	"INFOSEC_sdnsKMandSig" = "2.16.840.1.101.2.1.1.11"
	"INFOSEC_mosaicKMandSig" = "2.16.840.1.101.2.1.1.12"
	"INFOSEC_SuiteASignature" = "2.16.840.1.101.2.1.1.13"
	"INFOSEC_SuiteAConfidentiality" = "2.16.840.1.101.2.1.1.14"
	"INFOSEC_SuiteAIntegrity" = "2.16.840.1.101.2.1.1.15"
	"INFOSEC_SuiteATokenProtection" = "2.16.840.1.101.2.1.1.16"
	"INFOSEC_SuiteAKeyManagement" = "2.16.840.1.101.2.1.1.17"
	"INFOSEC_SuiteAKMandSig" = "2.16.840.1.101.2.1.1.18"
	"INFOSEC_mosaicUpdatedSig" = "2.16.840.1.101.2.1.1.19"
	"INFOSEC_mosaicKMandUpdSig" = "2.16.840.1.101.2.1.1.20"
	"INFOSEC_mosaicUpdatedInteg" = "2.16.840.1.101.2.1.1.21"
	"SUR_NAME" = "2.5.4.4"
	"STREET_ADDRESS" = "2.5.4.9"
	"DESCRIPTION" = "2.5.4.13"
	"SEARCH_GUIDE" = "2.5.4.14"
	"BUSINESS_CATEGORY" = "2.5.4.15"
	"POSTAL_ADDRESS" = "2.5.4.16"
	"POSTAL_CODE" = "2.5.4.17"
	"POST_OFFICE_BOX" = "2.5.4.18"
	"PHYSICAL_DELIVERY_OFFICE_NAME" = "2.5.4.19"
	"TELEPHONE_NUMBER" = "2.5.4.20"
	"TELEX_NUMBER" = "2.5.4.21"
	"TELETEXT_TERMINAL_IDENTIFIER" = "2.5.4.22"
	"FACSIMILE_TELEPHONE_NUMBER" = "2.5.4.23"
	"X21_ADDRESS" = "2.5.4.24"
	"INTERNATIONAL_ISDN_NUMBER" = "2.5.4.25"
	"REGISTERED_ADDRESS" = "2.5.4.26"
	"DESTINATION_INDICATOR" = "2.5.4.27"
	"PREFERRED_DELIVERY_METHOD" = "2.5.4.28"
	"PRESENTATION_ADDRESS" = "2.5.4.29"
	"SUPPORTED_APPLICATION_CONTEXT" = "2.5.4.30"
	"MEMBER" = "2.5.4.31"
	"OWNER" = "2.5.4.32"
	"ROLE_OCCUPANT" = "2.5.4.33"
	"SEE_ALSO" = "2.5.4.34"
	"USER_PASSWORD" = "2.5.4.35"
	"USER_CERTIFICATE" = "2.5.4.36"
	"CA_CERTIFICATE" = "2.5.4.37"
	"AUTHORITY_REVOCATION_LIST" = "2.5.4.38"
	"CERTIFICATE_REVOCATION_LIST" = "2.5.4.39"
	"CROSS_CERTIFICATE_PAIR" = "2.5.4.40"
	"GIVEN_NAME" = "2.5.4.42"
	"INITIALS" = "2.5.4.43"
	"PKCS_12_FRIENDLY_NAME_ATTR" = "1.2.840.113549.1.9.20"
	"PKCS_12_LOCAL_KEY_ID" = "1.2.840.113549.1.9.21"
	"PKCS_12_KEY_PROVIDER_NAME_ATTR" = "1.3.6.1.4.1.311.17.1"
	"LOCAL_MACHINE_KEYSET" = "1.3.6.1.4.1.311.17.2"
	"KEYID_RDN" = "1.3.6.1.4.1.311.10.7.1"
	"PKIX_ACC_DESCR" = "1.3.6.1.5.5.7.48"
	"PKIX_OCSP" = "1.3.6.1.5.5.7.48.1"
	"PKIX_CA_ISSUERS" = "1.3.6.1.5.5.7.48.2"
	"VERISIGN_PRIVATE_6_9" = "2.16.840.1.113733.1.6.9"
	"VERISIGN_ONSITE_JURISDICTION_HASH" = "2.16.840.1.113733.1.6.11"
	"VERISIGN_BITSTRING_6_13" = "2.16.840.1.113733.1.6.13"
	"VERISIGN_ISS_STRONG_CRYPTO" = "2.16.840.1.113733.1.8.1"
	"NETSCAPE" = "2.16.840.1.113730"
	"NETSCAPE_CERT_EXTENSION" = "2.16.840.1.113730.1"
	"NETSCAPE_CERT_TYPE" = "2.16.840.1.113730.1.1"
	"NETSCAPE_BASE_URL" = "2.16.840.1.113730.1.2"
	"NETSCAPE_REVOCATION_URL" = "2.16.840.1.113730.1.3"
	"NETSCAPE_CA_REVOCATION_URL" = "2.16.840.1.113730.1.4"
	"NETSCAPE_CERT_RENEWAL_URL" = "2.16.840.1.113730.1.7"
	"NETSCAPE_CA_POLICY_URL" = "2.16.840.1.113730.1.8"
	"NETSCAPE_SSL_SERVER_NAME" = "2.16.840.1.113730.1.12"
	"NETSCAPE_COMMENT" = "2.16.840.1.113730.1.13"
	"NETSCAPE_DATA_TYPE" = "2.16.840.1.113730.2"
	"NETSCAPE_CERT_SEQUENCE" = "2.16.840.1.113730.2.5"
	"CMC" = "1.3.6.1.5.5.7.7"
	"CMC_ADD_ATTRIBUTES" = "1.3.6.1.4.1.311.10.10.1"
	"PKCS_7_SIGNEDANDENVELOPED" = "1.2.840.113549.1.7.4"
	"CERT_PROP_ID_PREFIX" = "1.3.6.1.4.1.311.10.11."
	"CERT_KEY_IDENTIFIER_PROP_ID" = "1.3.6.1.4.1.311.10.11.20"
	"CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID" = "1.3.6.1.4.1.311.10.11.28"
	"CERT_SUBJECT_NAME_MD5_HASH_PROP_ID" = "1.3.6.1.4.1.311.10.11.29"

}

function Get-IntendedPurposeAdjudication {
    [CmdletBinding()]
    Param()

    # This function will be creating several $global: variables to be used outside of this function by the rest of the script
    # All variables that are NOT preceded by $global: must be set elsewhere BEFORE this funciton is executed
    # Variables that must be set BEFORE running this function are: $IntendedPurposeValues, $ValidIntendedPurposeValues, and $OIDHashTable

    # Using [System.Collections.ArrayList] so that Add and Remove methods work as expected and only operate on a single array 
    # instead of destroying and recreating arrays everytime an item is added/removed
    $global:CertRequestConfigFileStringsSectionArrayPrep = @()
    [System.Collections.ArrayList]$global:CertRequestConfigFileStringsSectionArray = $global:CertRequestConfigFileStringsSectionArrayPrep

    [array]$global:szOIDArrayPrep = @()
    [System.Collections.ArrayList]$global:szOIDArray = $global:szOIDArrayPrep

    [array]$global:ExtKeyUsePrep = @()
    [System.Collections.ArrayList]$global:ExtKeyUse = $global:ExtKeyUsePrep

    [array]$global:AppPolPrep = @()
    [System.Collections.ArrayList]$global:AppPol = $global:AppPolPrep

    # Validation check...
    foreach ($obj1 in $IntendedPurposeValues) {
        if ($ValidIntendedPurposeValues -notcontains $obj1) {
            Write-Host "$($obj1) is not a valid IntendedPurpose. Halting!"
            Write-Host "Valid IntendedPurpose values are as follows:"
            $ValidIntendedPurposeValuesString            
            Write-Error "$($obj1) is not a valid IntendedPurpose. Halting!"
            $global:FunctionResult = "1"
            return
        }
    }

    foreach ($obj1 in $IntendedPurposeValues) {
        if ($obj1 -eq "Code Signing") {
            $global:OfficialName = "PKIX_KP_CODE_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Document Signing") {
            $global:OfficialName = "KP_DOCUMENT_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Client Authentication") {
            $global:OfficialName = "PKIX_KP_CLIENT_AUTH"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Private Key Archival") {
            $global:OfficialName = "KP_CA_EXCHANGE"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Directory Service Email Replication") {
            $global:OfficialName = "DS_EMAIL_REPLICATION"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Key Recovery Agent") {
            $global:OfficialName = "KP_KEY_RECOVERY_AGENT"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "OCSP Signing") {
            $global:OfficialName = "KP_OCSP_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Server Authentication") {
            $global:OfficialName = "PKIX_KP_SERVER_AUTH"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        ##### Below this point, Intended Purposes will be set but WILL NOT show up in the Certificate Templates Console under Intended Purpose column #####
        if ($obj1 -eq "EFS") {
            $global:OfficialName = "KP_EFS"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Secure E-Mail") {
            $global:OfficialName = "PKIX_KP_EMAIL_PROTECTION"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Enrollment Agent") {
            $global:OfficialName = "ENROLLMENT_AGENT"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Microsoft Trust List Signing") {
            $global:OfficialName = "KP_CTL_USAGE_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Smartcard Logon") {
            $global:OfficialName = "IdMsKpScLogon"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "File Recovery") {
            $global:OfficialName = "EFS_RECOVERY"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "IPSec IKE Intermediate") {
            $global:OfficialName = "IPSEC_KP_IKE_INTERMEDIATE"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "KDC Authentication") {
            $global:OfficialName = "IdPkinitKPKdc"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        ##### Begin Newly Added #####
        if ($obj1 -eq "Remote Desktop") {
            $global:OfficialName = "Remote Desktop"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        # Cannot be overridden in Certificate Request
        if ($obj1 -eq "Windows Update") {
            $global:OfficialName = "Windows Update"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows Third Party Application Component") {
            $global:OfficialName = "Windows Third Party Application Component"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows TCB Component") {
            $global:OfficialName = "Windows TCB Component"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows Store") {
            $global:OfficialName = "Windows Store"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows Software Extension Verification") {
            $global:OfficialName = "Windows Software Extension Verification"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows RT Verification") {
            $global:OfficialName = "Windows RT Verification"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows Kits Component") {
            $global:OfficialName = "Windows Kits Component"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "No OCSP Failover to CRL") {
            $global:OfficialName = "No OCSP Failover to CRL"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Auto Update End Revocation") {
            $global:OfficialName = "Auto Update End Revocation"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Auto Update CA Revocation") {
            $global:OfficialName = "Auto Update CA Revocation"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Revoked List Signer") {
            $global:OfficialName = "Revoked List Signer"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Protected Process Verification") {
            $global:OfficialName = "Protected Process Verification"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Protected Process Light Verification") {
            $global:OfficialName = "Protected Process Light Verification"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Platform Certificate") {
            $global:OfficialName = "Platform Certificate"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Microsoft Publisher") {
            $global:OfficialName = "Microsoft Publisher"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Kernel Mode Code Signing") {
            $global:OfficialName = "Kernel Mode Code Signing"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "HAL Extension") {
            $global:OfficialName = "HAL Extension"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Endorsement Key Certificate") {
            $global:OfficialName = "Endorsement Key Certificate"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Early Launch Antimalware Driver") {
            $global:OfficialName = "Early Launch Antimalware Driver"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Dynamic Code Generator") {
            $global:OfficialName = "Dynamic Code Generator"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "DNS Server Trust") {
            $global:OfficialName = "DNS Server Trust"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Document Encryption") {
            $global:OfficialName = "Document Encryption"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Disallowed List") {
            $global:OfficialName = "Disallowed List"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Attestation Identity Key Certificate") {
            $global:OfficialName = "Attestation Identity Key Certificate"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "System Health Authentication") {
            $global:OfficialName = "System Health Authentication"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "CTL Usage") {
            $global:OfficialName = "AUTO_ENROLL_CTL_USAGE"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "IP Security End System") {
            $global:OfficialName = "PKIX_KP_IPSEC_END_SYSTEM"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "IP Security Tunnel Termination") {
            $global:OfficialName = "PKIX_KP_IPSEC_TUNNEL"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "IP Security User") {
            $global:OfficialName = "PKIX_KP_IPSEC_USER"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Time Stamping") {
            $global:OfficialName = "PKIX_KP_TIMESTAMP_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Microsoft Time Stamping") {
            $global:OfficialName = "KP_TIME_STAMP_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows Hardware Driver Verification") {
            $global:OfficialName = "WHQL_CRYPTO"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Windows System Component Verification") {
            $global:OfficialName = "NT5_CRYPTO"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "OEM Windows System Component Verification") {
            $global:OfficialName = "OEM_WHQL_CRYPTO"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Embedded Windows System Component Verification") {
            $global:OfficialName = "EMBEDDED_NT_CRYPTO"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Root List Signer") {
            $global:OfficialName = "ROOT_LIST_SIGNER"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Qualified Subordination") {
            $global:OfficialName = "KP_QUALIFIED_SUBORDINATION"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Key Recovery") {
            $global:OfficialName = "KP_KEY_RECOVERY"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Lifetime Signing") {
            $global:OfficialName = "KP_LIFETIME_SIGNING"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "Key Pack Licenses") {
            $global:OfficialName = "LICENSES"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
        if ($obj1 -eq "License Server Verification") {
            $global:OfficialName = "LICENSE_SERVER"
            $global:OfficialOID = $OIDHashTable.$global:OfficialName
            $global:szOIDArray.Add("szOID_$global:OfficialName")
            $global:CertRequestConfigFileStringsSectionArray.Add("szOID_$global:OfficialName = `"$global:OfficialOID`"")
            $global:ExtKeyUse.Add("$global:OfficialOID")
            $global:AppPol.Add("$global:OfficialOID")
        }
    }
}

##### END Libraries and Helper Functions #####

##### BEGIN Initial Variable Definition and Validation #####
$DomainPrefix = ((gwmi Win32_ComputerSystem).Domain).Split(".") | Select-Object -Index 0
$DomainSuffix = ((gwmi Win32_ComputerSystem).Domain).Split(".") | Select-Object -Index 1
$Hostname = (gwmi Win32_ComputerSystem).Name
$HostFQDN = $Hostname+'.'+$DomainPrefix+'.'+$DomainSuffix

# Check RSAT Feature Dependency if NOT Requesting via ADCS Web Enrollment site...
if ($RequestViaWebEnrollment -eq "No" -or $RequestViaWebEnrollment -eq "n") { 
    $NeededRSATFeatures =  @("RSAT","RSAT-Role-Tools","RSAT-AD-Tools","RSAT-AD-PowerShell","RSAT-ADDS","RSAT-AD-AdminCenter","RSAT-ADDS-Tools","RSAT-ADLDS")
    foreach ($obj1 in $NeededRSATFeatures) {
        if ($(Get-WindowsFeature -Name $obj1).Installed) {
            Write-Host "$obj1 is installed. Continuing..."
        }
        else {
            Write-Host "$obj1 is NOT installed. Please install $obj1 and try again."
            $global:FunctionResult = "1"
            return
        }
    }
}

# If using Win32 OpenSSL, check to make sure the path to binary is valid...
if ($UseOpenSSL -eq "Yes" -or $UseOpenSSL -eq "y") {
    if ($PathToWin32OpenSSL -eq $null) {
        Write-Host "You have indicated that you would like to use Win32 OpenSSL to create certificate files in formats compatible with Linux."
        $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the full path to the directory containing the Win32 OpenSSL binary"
    }
    if (Test-Path $PathToWin32OpenSSL) {
        Write-Host "Path to Win32 OpenSSL directory is valid...Continuing..."
    }
    if (! (Test-Path $PathToWin32OpenSSL)) {
        Write-Host "The path to the directory containing the Win32 OpenSSL binary is not valid."
        $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the path to the Win32 OpenSSL binary directory"
        if (Test-Path $PathToWin32OpenSSL) {
            Write-Host "Path to Win32 OpenSSL directory is valid...Continuing..."
        }
        if (! (Test-Path $PathToWin32OpenSSL)) {
            Write-Host "The path to the directory containing the Win32 OpenSSL binary is not valid."
            $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the path to the Win32 OpenSSL binary directory"
            if (Test-Path $PathToWin32OpenSSL) {
                Write-Host "Path to Win32 OpenSSL directory is valid...Continuing..."
            }
            else {
                Write-Host "Win32 OpenSSL binary directory not found. Halting!"
                $global:FunctionResult = "1"
                return
            }
        }
    }
}

# Check for contradictions in $MachineKeySet value and $PrivateKeyExportableValue and $UseOpenSSL
if ($MachineKeySet -eq "TRUE" -and $PrivateKeyExportableValue -eq "TRUE") {
    Pause-ForWarning -PauseTimeInSeconds 10 -Message "MachineKeySet and PrivateKeyExportableValue have both been set to TRUE, but Private Key cannot be exported
    if MachineKeySet = TRUE. If you continue, you will be asked if you want the Private Key to be exportable. Do you want to continue?"
    if ($global:FunctionResult -ne 0) {
        Write-Host "The function Pause-ForWarning failed! Continuing..."
        Write-Error "The function Pause-ForWarning failed! Continuing..."
        $global:FunctionResult = "1"
    }
    $ShouldPrivKeyBeExportable = Read-Host -Prompt "Would you like the Private Key to be exportable? [Yes/No]"
    if ($ShouldPrivKeyBeExportable -eq "Yes" -or $ShouldPrivKeyBeExportable -eq "y") {
        $MachineKeySet = "FALSE"
        $PrivateKeyExportableValue = "TRUE"
    }
    else {
        $MachineKeySet = "TRUE"
        $PrivateKeyExportableValue = "FALSE"
    }
}
if ($MachineKeySet -eq "TRUE" -and $UseOpenSSL -eq "Yes") {
    Pause-ForWarning -PauseTimeInSeconds 10 -Message "MachineKeySet and UseOpenSSL have both been set to TRUE. Win32 OpenSSL targets a .pfx file exported from the 
    local Certificate Store. If MachineKeySet is set to TRUE, no .pfx file will be exported from the local Certificate Store. If you continue, you will be asked
    if you want to use Win32 OpenSSL to generate keys in formats compatible with Linux. Do you want to continue?"
    if ($global:FunctionResult -ne 0) {
        Write-Host "The function Pause-ForWarning failed! Continuing..."
        Write-Error "The function Pause-ForWarning failed! Continuing..."
        $global:FunctionResult = "1"
    }
    $ShouldUseOpenSSL = Read-Host -Prompt "Would you like to use Win32 OpenSSL in order to generate keys in formats compatible with Linux? [Yes\No]"
    if ($ShouldUseOpenSSL -eq "Yes" -or $ShouldUseOpenSSL -eq "y") {
        $MachineKeySet = "FALSE"
        $UseOpenSSL = "Yes"
    }
    else {
        $MachineKeySet = "TRUE"
        $UseOpenSSL = "No"
    }
}

if ($MachineKeySet -eq "FALSE" -and $PFXPwdAsSecureString -eq $null) {
    Read-Host -Prompt "Please enter a password to use when exporting .pfx bundle certificate/key bundle" -AsSecureString
}
if ($PFXPwdAsSecureString.GetType().Name -eq "String") {
    $PFXPwdAsSecureString = ConvertTo-SecureString -String $PFXPwdAsSecureString -Force –AsPlainText
}

# If the workstation being used to request the Certificate is part of the same Domain as the Issuing Certificate Authority, leverage certutil...
if ($RequestViaWebEnrollment -eq "No" -or $RequestViaWebEnrollment -eq "n") {
    $AvailableCertificateAuthorities = (((certutil | Select-String -Pattern "Config:") -replace "Config:[\s]{1,32}``") -replace "'","").trim()
    $IssuingCertAuth = foreach ($obj1 in $AvailableCertificateAuthorities) {
        $obj2 = certutil -config $obj1 -CAInfo type | Select-String -Pattern "Enterprise Subordinate CA" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
        if ($obj2 -eq "Enterprise Subordinate CA") {
            $obj1
        }
    }
    $IssuingCertAuthFQDN = $IssuingCertAuth.Split("\") | Select-Object -Index 0
    $IssuingCertAuthHostname = $IssuingCertAuth.Split("\") | Select-Object -Index 1
    certutil -config $IssuingCertAuth -ping
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Successfully contacted the server acting as the Issuing Certificate Authority"
    }
    else {
        Write-Host "Cannot contact the Issuing Certificate Authority. Halting!"
        $global:FunctionResult = "1"
        return
    }
    $LDAPSearchBase = "CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=$DomainPrefix,DC=$DomainSuffix"
    # $AllAvailableCertificateTemplates Using PSPKI
    # $AllAvailableCertificateTemplates = Get-PSPKICertificateTemplate
    # Using certutil
    $AllAvailableCertificateTemplatesPrep = certutil -ADTemplate
    # Determine valid CN using PSPKI
    # $ValidCertificateTemplatesByCN = $AllAvailableCertificateTemplatesPrep.Name
    # Determine valid displayNames using certutil
    $ValidCertificateTemplatesByCN = foreach ($obj1 in $AllAvailableCertificateTemplatesPrep) {
        $obj2 = $obj1 | Select-String -Pattern "[\w]{1,32}:[\s][\w]" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
        $obj3 = $obj2 -replace ':[\s][\w]',''
        $obj3
    }
    $ValidCNNamesAsStringPrep = foreach ($obj1 in $ValidCertificateTemplatesByCN) {
        $obj1.Trim()+','
    }
    $ValidCNNamesAsString = [string]$ValidCNNamesAsStringPrep

    # Determine valid displayNames using PSPKI
    # $ValidCertificateTemplatesByDisplayName = $AllAvailableCertificateTemplatesPrep.DisplayName
    # Determine valid displayNames using certutil
    $ValidCertificateTemplatesByDisplayName = foreach ($obj1 in $AllAvailableCertificateTemplatesPrep) {
        $obj2 = $obj1 | Select-String -Pattern "\:(.*)\-\-" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
        $obj3 = ($obj2 -replace ": ","") -replace " --",""
        $obj3
    }
    $ValidDisplayNamesAsStringPrep = foreach ($obj1 in $ValidCertificateTemplatesByDisplayName) {
        $obj1.Trim()+','
    }
    $ValidDisplayNamesAsString = [string]$ValidDisplayNamesAsStringPrep

    # Set displayName and CN Values for user-provided $BasisTemplate
    if ($ValidCertificateTemplatesByCN -contains $BasisTemplate) {
        $cnForBasisTemplate = $BasisTemplate
    }
    if ($ValidCertificateTemplatesByDisplayName -contains $BasisTemplate) {
        $displayNameForBasisTemplate = $BasisTemplate
    }

    if ($cnForBasisTemplate -eq $null -and $displayNameForBasisTemplate -ne $null) {
        $cnForBasisTemplatePrep1 = $AllAvailableCertificateTemplatesPrep | Select-String -Pattern $displayNameForBasisTemplate | Select-Object -ExpandProperty Line
        $cnForBasisTemplatePrep2 = $cnForBasisTemplatePrep1 | Select-String -Pattern "[\w]{1,32}:[\s][\w]" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
        $cnForBasisTemplate = $cnForBasisTemplatePrep2 -replace ':[\s][\w]',''
    }
    if ($cnForBasisTemplate -ne $null -and $displayNameForBasisTemplate -eq $null) {
        $displayNameForBasisTemplatePrep1 = $AllAvailableCertificateTemplatesPrep | Select-String -Pattern $cnForBasisTemplate | Select-Object -ExpandProperty Line
        $displayNameForBasisTemplatePrep2 = $displayNameForBasisTemplatePrep1 | Select-String -Pattern "\:(.*)\-\-" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
        $displayNameForBasisTemplate = ($displayNameForBasisTemplatePrep2 -replace ": ","") -replace " --",""
    }

    # ---------

    if ($ValidCertificateTemplatesByCN -notcontains $BasisTemplate -and $ValidCertificateTemplatesByDisplayName -notcontains $BasisTemplate) {
        Write-Host ""
        Write-Host ""
        Write-Host "You must base your New Certificate Template on an existing Certificate Template."
        Write-Host "To do so, please enter either the displayName or CN of the Certificate Template you would like to use as your base."
        Write-Host ""
        Write-Host "Valid displayName values are as follows:"
        Write-Host ""
        $ValidDisplayNamesAsString
        Write-Host ""
        Sleep 2
        Write-Host "Valid CN values are as follows:"
        Write-Host""
        $ValidCNNamesAsString
        Write-Host""

        $BasisTemplate = Read-Host -Prompt "Please enter the displayName or CN of the Certificate Template you would like to use as your base"
        # Set displayName and CN Values for user-provided $BasisTemplate
        if ($ValidCertificateTemplatesByCN -contains $BasisTemplate) {
            $cnForBasisTemplate = $BasisTemplate
        }
        if ($ValidCertificateTemplatesByDisplayName -contains $BasisTemplate) {
            $displayNameForBasisTemplate = $BasisTemplate
        }
        if ($ValidCertificateTemplatesByCN -notcontains $BasisTemplate -and $ValidCertificateTemplatesByDisplayName -notcontains $BasisTemplate) {
            Write-Host ""
            Write-Host ""
            Write-Host "You must base your New Certificate Template on an existing Certificate Template."
            Write-Host "To do so, please enter either the displayName or CN of the Certificate Template you would like to use as your base. Halting!"
        }
    }

    # Get all Certificate Template Properties of the Basis Template
    $CertificateTemplateLDAPObject = "CN=$cnForBasisTemplate,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=$DomainPrefix,DC=$DomainSuffix"
    $AllCertificateTemplateProperties = Get-ADObject $CertificateTemplateLDAPObject -Properties *
    $ConfigContext = ([ADSI]"LDAP://RootDSE").ConfigurationNamingContext
    $ADSI = [ADSI]"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$ConfigContext"

    Write-Host "Writing all attributes of Certificate Template that this New Certificate is Based On for user awareness/reference"
    Sleep 2
    $AllCertificateTemplateProperties
    Sleep 2
}

# If the workstation being used to request the Certificate is NOT part of the same Domain as the Issuing Certificate Authority, use ADCS Web Enrollment Site...
if ($RequestViaWebEnrollment -eq "Yes" -or $RequestViaWebEnrollment -eq "y") {
    # Set $ADCSWebEnrollmentURL if it hasn't been set yet
    if ($ADCSWebEnrollmentURL -eq $null) {
        $ADCSWebEnrollmentURL = Read-Host -Prompt "Please enter the URL of the ADCS Web Enrollment website
        Example: https://pki.zero.lab/certsrv"
    }
    # Make sure there is no trailing / on $ADCSWebEnrollmentURL
    if ($ADCSWebEnrollmentURL.EndsWith('/')) {
        $ADCSWebEnrollmentURL = $ADCSWebEnrollmentURL.Substring(0,$ADCSWebEnrollmentURL.Length-1)
    } 

    # The IIS Web Server hosting ADCS Web Enrollment may be configured for Windows Authentication, Basic Authentication, or both.
    # Validate the type of Authentication...
    if ($ADCSWebAuthType -eq $null) {
        Write-Host "The IIS Web Server hosting ADCS Web Enrollment may be configured for Windows Authentication, Basic Authentication, or both."
        $ADCSWebAuthType = Read-Host -Prompt "Which type of Authentication will you use to authenticate against the ADCS Web Enrollment site? [Windows/Basic]"
    }

    if ($ADCSWebAuthType -like "*Windows*") {
        if ($ADCSWebAuthUserName -eq $null) {
            $ADCSWebAuthUserName = Read-Host -Prompt "Please specify the AD account to be used for ADCS Web Enrollment authentication.
            Do NOT include the domain prefix. Example: testadmin"
        }
        if ($ADCSWebAuthUserName -match "[\w\W]\\[\w\W]") {
            $ADCSWebAuthUserName = $ADCSWebAuthUserName.Split("\")[1]
        }

        if ($ADCSWebAuthPass -eq $null) {
            $ADCSWebAuthPass = Read-Host -Prompt "Please enter a password to be used for ADCS Web Enrollment authentication" -AsSecureString
        }
        # If $ADCSWebAuthPass has already been set, and it is Plaintext, convert it to a Secure String...
        if ($ADCSWebAuthPass.GetType().Name -eq "String") {
            $ADCSWebAuthPass = ConvertTo-SecureString -String $ADCSWebAuthPass -Force –AsPlainText
        }
        
        if ($ADCSWebCreds -eq $null) {
            $ADCSWebCreds = New-Object System.Management.Automation.PSCredential ($ADCSWebAuthUserName, $ADCSWebAuthPass)
        }
        else {
            $ADCSWebCreds = New-Object System.Management.Automation.PSCredential ($ADCSWebAuthUserName, $ADCSWebAuthPass)
        }

        # Test Connection to $ADCSWebEnrollmentURL
        # Validate $ADCSWebEnrollmentURL...
        $statusCode = Invoke-WebRequest -Uri "$ADCSWebEnrollmentURL/" -Credential $ADCSWebCreds | % {$_.StatusCode}
        if ($statusCode -eq "200") {
            Write-Host "Connection to $ADCSWebEnrollmentURL was successful...continuing"
        }
        else {
            Write-Host "Connection to $ADCSWebEnrollmentURL was NOT successful. Please check your credentials and/or DNS."
            $global:FunctionResult = "1"
            return
        }

        # Check available Certificate Templates...
        $CertTemplCheckInitialResponse = Invoke-WebRequest -Uri "$ADCSWebEnrollmentURL/certrqxt.asp" -Credential $ADCSWebCreds
        $ValidADCSWebEnrollCertTemplatesPrep = ($CertTemplCheckInitialResponse.RawContent.Split("`r") | Select-String -Pattern 'Option Value=".*').Matches.Value
        $ValidADCSWEbEnrollCertTemplates = foreach ($obj1 in $ValidADCSWebEnrollCertTemplatesPrep) {
            $obj1.Split(";")[1]
        }
        # Validate specified Certificate Template...
        if ($ValidADCSWebEnrollCertTemplates -notcontains $BasisTemplate) {
            Write-Host "$BaisTemplate is not on the list of available Certificate Templates on the ADCS Web Enrollment site." 
            Write-Host "IMPORTANT NOTE: For a Certificate Template to appear in the Certificate Template drop-down on the ADCS Web Enrollment site,
            msPKITemplateSchemaVersion MUST BE '2' or '1' AND pKIExpirationPeriod MUST BE 1 year or LESS"
            Write-Host "Certificate Templates available via ADCS Web Enrollment are as follows:"
            $ValidADCSWebEnrollCertTemplates
            $BasisTemplate = Read-Host -Prompt "Please enter the name of an existing Certificate Template that you would like your New Certificate to be based on"
        }
    }
    if ($ADCSWebAuthType -like "*Basic*") {
        if ($ADCSWebAuthUserName -eq $null) {
            $ADCSWebAuthUserName = Read-Host -Prompt "Please specify the AD account to be used for ADCS Web Enrollment authentication.
            Please *include* the domain prefix. Example: test\testadmin"
        }
        if (! $ADCSWebAuthUserName -match "[\w\W]\\[\w\W]") {
            Write-Host "Please include the domain prefix before the username. Example: test\testadmin"
            $ADCSWebAuthUserName = Read-Host -Prompt "Please specify the AD account to be used for ADCS Web Enrollment authentication.
            Please *include* the domain prefix. Example: test\testadmin"
        }

        if ($ADCSWebAuthPass -eq $null) {
            $ADCSWebAuthPass = Read-Host -Prompt "Please enter a password to be used for ADCS Web Enrollment authentication"
        }
        # If $ADCSWebAuthPass is a Secure String, convert it back to Plaintext
        if ($ADCSWebAuthPass.GetType().Name -eq "SecureString") {
            $ADCSWebAuthPass = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($ADCSWebAuthPass))
        }

        $pair = "${$ADCSWebAuthUserName}:${$ADCSWebAuthPass}"
        $bytes = [System.Text.Encoding]::ASCII.GetBytes($pair)
        $base64 = [System.Convert]::ToBase64String($bytes)
        $basicAuthValue = "Basic $base64"
        $headers = @{ Authorization = $basicAuthValue }

        # Test Connection to $ADCSWebEnrollmentURL
        # Validate $ADCSWebEnrollmentURL...
        $statusCode = Invoke-WebRequest -Uri "$ADCSWebEnrollmentURL/" -Headers $headers | % {$_.StatusCode}
        if ($statusCode -eq "200") {
            Write-Host "Connection to $ADCSWebEnrollmentURL was successful...continuing"
        }
        else {
            Write-Host "Connection to $ADCSWebEnrollmentURL was NOT successful. Please check your credentials and/or DNS."
        }

        # Check available Certificate Templates...
        $CertTemplCheckInitialResponse = Invoke-WebRequest -Uri "$ADCSWebEnrollmentURL/certrqxt.asp" -Headers $headers
        $ValidADCSWebEnrollCertTemplatesPrep = ($CertTemplCheckInitialResponse.RawContent.Split("`r") | Select-String -Pattern 'Option Value=".*').Matches.Value
        $ValidADCSWEbEnrollCertTemplates = foreach ($obj1 in $ValidADCSWebEnrollCertTemplatesPrep) {
            $obj1.Split(";")[1]
        }
        # Validate specified Certificate Template...
        if ($ValidADCSWebEnrollCertTemplates -notcontains $BasisTemplate) {
            Write-Host "$BaisTemplate is not on the list of available Certificate Templates on the ADCS Web Enrollment site." 
            Write-Host "IMPORTANT NOTE: For a Certificate Template to appear in the Certificate Template drop-down on the ADCS Web Enrollment site,
            msPKITemplateSchemaVersion MUST BE '2' or '1' AND pKIExpirationPeriod MUST BE 1 year or LESS"
            Write-Host "Certificate Templates available via ADCS Web Enrollment are as follows:"
            $ValidADCSWebEnrollCertTemplates
            $BasisTemplate = Read-Host -Prompt "Please enter the name of an existing Certificate Template that you would like your New Certificate to be based on"
        }
    }
}

# Make a working Directory Where Genrated Certificates will be Saved
if (Test-Path $CertGenWorking) {
    Write-Host "The working directory $CertGenWorking already exists. No action necessary."
}
else {
    $CertGenWorking = Read-Host -Prompt "Please enter the full path to the directory you would like to use for all file outputs."
    mkdir $CertGenWorking
}

if ($KeyLengthOverride -eq "Yes" -or $KeyLengthOverride -eq "y" -or $KeyLengthOverride -eq "No" -or $KeyLengthOverride -eq "n") {
    Write-Host "The value for KeyLengthOverride is valid...continuing"
}
else {
    Write-Host "The value for KeyLengthOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($HashAlgorithmOverride -eq "Yes" -or $HashAlgorithmOverride -eq "y" -or $HashAlgorithmOverride -eq "No" -or $HashAlgorithmOverride -eq "n") {
    Write-Host "The value for HashAlgorithmOverride is valid...continuing"
}
else {
    Write-Host "The value for HashAlgorithmOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

<#
# KeyAlgorithm should be determined by ProviderName. Run "certutil -csplist" to see which Providers use which Key Algorithms
if ($KeyAlgorithmOverride -eq "Yes" -or $KeyAlgorithmOverride -eq "y" -or $KeyAlgorithmOverride -eq "No" -or $KeyAlgorithmOverride -eq "n") {
    Write-Host "The value for KeyAlgorithmOverride is valid...continuing"
}
else {
    Write-Host "The value for KeyAlgorithmOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}
#>

if ($EncryptionAlgorithmOverride -eq "Yes" -or $EncryptionAlgorithmOverride -eq "y" -or $EncryptionAlgorithmOverride -eq "No" -or $EncryptionAlgorithmOverride -eq "n") {
    Write-Host "The value for EncryptionAlgorithmOverride is valid...continuing"
}
else {
    Write-Host "The value for EncryptionAlgorithmOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($PrivateKeyExportableOverride -eq "Yes" -or $PrivateKeyExportableOverride -eq "y" -or $PrivateKeyExportableOverride -eq "No" -or $PrivateKeyExportableOverride -eq "n") {
    Write-Host "The value for PrivateKeyExportableOverride is valid...continuing"
}
else {
    Write-Host "The value for PrivateKeyExportableOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($KeySpecOverride -eq "Yes" -or $KeySpecOverride -eq "y" -or $KeySpecOverride -eq "No" -or $KeySpecOverride -eq "n") {
    Write-Host "The value for KeySpecOverride is valid...continuing"
}
else {
    Write-Host "The value for KeySpecOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($KeyUsageOverride -eq "Yes" -or $KeyUsageOverride -eq "y" -or $KeyUsageOverride -eq "No" -or $KeyUsageOverride -eq "n") {
    Write-Host "The value for KeyUsageOverride is valid...continuing"
}
else {
    Write-Host "The value for KeyUsageOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($MachineKeySet -eq "TRUE" -or $MachineKeySet -eq "FALSE") {
    Write-Host "The value for MachineKeySet is valid...continuing"
}
else {
    Write-Host "The value for MachineKeySet is not valid. Please use either 'TRUE', 'FALSE'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($SecureEmail -eq "Yes" -or $SecureEmail -eq "y" -or $SecureEmail -eq "No" -or $SecureEmail -eq "n") {
    Write-Host "The value for SecureEmail is valid...continuing"
}
else {
    Write-Host "The value for SecureEmail is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($UserProtected -eq "Yes" -or $UserProtected -eq "y" -or $UserProtected -eq "No" -or $UserProtected -eq "n") {
    Write-Host "The value for UserProtected is valid...continuing"
}
else {
    Write-Host "The value for UserProtected is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($ProviderNameOverride -eq "Yes" -or $ProviderNameOverride -eq "y" -or $ProviderNameOverride -eq "No" -or $ProviderNameOverride -eq "n") {
    Write-Host "The value for ProviderNameOverride is valid...continuing"
}
else {
    Write-Host "The value for ProviderNameOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($RequestTypeOverride -eq "Yes" -or $RequestTypeOverride -eq "y" -or $RequestTypeOverride -eq "No" -or $RequestTypeOverride -eq "n") {
    Write-Host "The value for RequestTypeOverride is valid...continuing"
}
else {
    Write-Host "The value for RequestTypeOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

if ($UseOpenSSL -eq "Yes" -or $UseOpenSSL -eq "y" -or $UseOpenSSL -eq "No" -or $UseOpenSSL -eq "n") {
    Write-Host "The value for UseOpenSSL is valid...continuing"
}
else {
    Write-Host "The value for UseOpenSSL is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    $global:FunctionResult = "1"
    return
}

# Validate $IntendedPurposeValuesPrep
$ValidIntendedPurposeValues = @("Code Signing","Document Signing","Client Authentication","Server Authentication",`
"Remote Desktop","Private Key Archival","Directory Service Email Replication","Key Recovery Agent",`
"OCSP Signing","Microsoft Trust List Signing","EFS","Secure E-mail","Enrollment Agent","Smart Card Logon",`
"File Recovery","IPSec IKE Intermediate","KDC Authentication","Windows Update",`
"Windows Third Party Application Component","Windows TCB Component","Windows Store",`
"Windows Software Extension Verification","Windows RT Verification","Windows Kits Component",`
"No OCSP Failover to CRL","Auto Update End Revocation","Auto Update CA Revocation","Revoked List Signer",`
"Protected Process Verification","Protected Process Light Verification","Platform Certificate",`
"Microsoft Publisher","Kernel Mode Code Signing","HAL Extension","Endorsement Key Certificate",`
"Early Launch Antimalware Driver","Dynamic Code Generator","DNS Server Trust","Document Encryption",`
"Disallowed List","Attestation Identity Key Certificate","System Health Authentication","CTL Usage",`
"IP Security End System","IP Security Tunnel Termination","IP Security User","Time Stamping",`
"Microsoft Time Stamping","Windows Hardware Driver Verification","Windows System Component Verification",`
"OEM Windows System Component Verification","Embedded Windows System Component Verification","Root List Signer",`
"Qualified Subordination","Key Recovery","Lifetime Signing","Key Pack Licenses","License Server Verification")
$ValidIntendedPurposeValuesStringPrep = foreach ($obj1 in $ValidIntendedPurposeValues) {
    $obj1+','
}
$ValidIntendedPurposeValuesString = [string]$ValidIntendedPurposeValuesStringPrep
# Comment below "$IntednedPurposeValues -eq $null" check because under this circumstance, certificate will use
# IntendedPurposeValues from Basis Certificate Template. This is handled around line 1990.
<#
if ($IntendedPurposeValuesPrep -eq $null) {
    Write-Host ""
    Write-Host "Your new Certificate Template must have one or more Intended Purposes"
    Write-Host "Valid Intended Purpose values are as follows:"
    Write-Host ""
    $ValidIntendedPurposeValuesString
    Write-Host ""
    $IntendedPurposeValuesPrep = Read-Host -Prompt "Please enter one (or more) Intended Purpose values separated by commas"
}
#>
if ($IntendedPurposeValuesPrep -ne $null) {
    if (($IntendedPurposeValuesPrep.GetType().Name) -eq "String") {
        $IntendedPurposeValues = $IntendedPurposeValuesPrep.Split(",").Trim()
    }
    if (($IntendedPurposeValuesPrep.GetType().BaseType.Name) -eq "Array") {
        $IntendedPurposeValues = $IntendedPurposeValuesPrep
    }

    # Validation check...
    if (Compare-Arrays -LargerArray $ValidIntendedPurposeValues -SmallerArray $IntendedPurposeValues) {
        Write-Host "IntendedPurposeValues are valid...Continuing..."
    }
    else {
        Write-Host "One or more IntendedPurposeValues are NOT valid. Valid Intended Purpose Values are as follows:"
        Write-Host ""
        $ValidIntendedPurposeValuesString
        Write-Host ""
        $IntendedPurposeValuesPrep = Read-Host -Prompt "Please enter one or more Indended Purpose Values separated by commas"
        if (($IntendedPurposeValuesPrep.GetType().Name) -eq "String") {
            $IntendedPurposeValues = $IntendedPurposeValuesPrep.Split(",").Trim()
        }
        if (($IntendedPurposeValuesPrep.GetType().BaseType.Name) -eq "Array") {
            $IntendedPurposeValues = $IntendedPurposeValuesPrep
        }
  
        # Validation check...
        if (Compare-Arrays -LargerArray $ValidIntendedPurposeValues -SmallerArray $IntendedPurposeValues) {
            Write-Host "IntendedPurposeValues are valid...Continuing..."
        }
        else {
            Write-Host "One or more IntendedPurposeValues are NOT valid. Halting!"
            $global:FunctionResult = "1"
            return
        }
    }
}

if ($RequestViaWebEnrollment -eq "No" -or $RequestViaWebEnrollment -eq "n") {
    # Validate $ProviderNameValuePrep
    # All available Cryptographic Providers (CSPs) are as follows:
    $PossibleProvidersPrep = certutil -csplist | Select-String "Provider Name" -Context 0,1
    $PossibleProviders = foreach ($obj1 in $PossibleProvidersPrep) {
        $obj2 = $obj1.Context.PostContext | Select-String 'FAIL' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Success
        $obj3 = $obj1.Context.PostContext | Select-String 'not ready' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Success
        if ($obj2 -ne "True" -and $obj3 -ne "True") {
            $obj1.Line -replace "Provider Name: ",""
        }
    }
    # Available Cryptographic Providers (CSPs) based on user choice in Certificate Template (i.e. $BasisTemplate)
    # Does the Basis Certificate Template LDAP Object have an attribute called pKIDefaultCSPs that is set?
    $CertificateTemplateLDAPObjectSetAttributes = Get-ADObject $CertificateTemplateLDAPObject -Properties * | Select-Object -ExpandProperty PropertyNames
    if ($CertificateTemplateLDAPObjectSetAttributes -notcontains "pKIDefaultCSPs") {
        Write-Host "The Basis Template $BasisTemplate does NOT have the attribute pKIDefaultCSPs set."
        Write-Host "This means that Cryptographic Providers are NOT Limited, and (almost) any ProviderNameValue is valid"
        $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
        foreach ($obj1 in $ProviderNameValue) {
            if ($PossibleProviders -notcontains $obj1) {
                Write-Host "$($obj1) is not a valid ProviderNameValue. Valid Provider Names based on your choice in Basis Certificate Template are as follows:"
                $PossibleProviders
                $ProviderNameValuePrep = $(Read-Host -Prompt "Please enter the name of the Cryptographic Provider (CSP) you would like to use")
                $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
                # Validation check...
                foreach ($obj1 in $ProviderNameValue) {
                    if ($PossibleProviders -notcontains $obj1) {
                        Write-Host "$($obj1) is not a valid ProviderNameValue. Halting!"
                        $global:FunctionResult = "1"
                        return
                    }
                }
            }
        }
    }
    else {
        $AvailableCSPsBasedOnCertificateTemplate = (Get-ADObject $CertificateTemplateLDAPObject -Properties * | Select-Object -ExpandProperty pkiDefaultCSPs) -replace '[0-9],',''
        # NOTE: There can only be one (1) ProviderNameValue. Maybe no need to use array.
        $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
        foreach ($obj1 in $ProviderNameValue) {
            if ($AvailableCSPsBasedOnCertificateTemplate -notcontains $obj1) {
                Write-Host "$($obj1) is not a valid ProviderNameValue. Valid Provider Names based on your choice in Basis Certificate Template are as follows:"
                $AvailableCSPsBasedOnCertificateTemplate
                $ProviderNameValuePrep = $(Read-Host -Prompt "Please enter the name of the Cryptographic Provider (CSP) you would like to use")
                $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
                # Validation check...
                foreach ($obj1 in $ProviderNameValue) {
                    if ($AvailableCSPsBasedOnCertificateTemplate -notcontains $obj1) {
                        Write-Host "$($obj1) is not a valid ProviderNameValue. Halting!"
                        $global:FunctionResult = "1"
                        return
                    }
                }
            }
        }
    }
}
if ($RequestViaWebEnrollment -eq "Yes" -or $RequestViaWebEnrollment -eq "y") {
    $CertTemplvsCSPHash = @{}
    $ValidADCSWebEnrollCSPsPrep = ($CertTemplCheckInitialResponse.RawContent.Split("`r") | Select-String -Pattern 'Option Value=".*').Matches.Value
    $ValidADCSWebEnrollCSPsPrep2 = foreach ($obj1 in $ValidADCSWebEnrollCSPsPrep) {
        $obj2 = $obj1.Split(";")[1]
        $obj3 = ($obj1.Split(";")[8]) -replace '\?',', '
        $CertTemplvsCSPHash.Add("$obj2", "$obj3")
    }
    $ValidADCSWebEnrollCSPs = $CertTemplvsCSPHash.$BasisTemplate.Split(",").Trim()

    # NOTE: There can only be one (1) ProviderNameValue. Maybe no need to use array.
    $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
    foreach ($obj1 in $ProviderNameValue) {
        if ($ValidADCSWebEnrollCSPs -notcontains $obj1) {
            Write-Host "$($obj1) is not a valid ProviderNameValue. Valid Provider Names based on your choice in Basis Certificate Template are as follows:"
            $ValidADCSWebEnrollCSPs
            $ProviderNameValuePrep = $(Read-Host -Prompt "Please enter the name of the Cryptographic Provider (CSP) you would like to use")
            $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
            # Validation check...
            foreach ($obj1 in $ProviderNameValue) {
                if ($ValidADCSWebEnrollCSPs -notcontains $obj1) {
                    Write-Host "$($obj1) is not a valid ProviderNameValue. Halting!"
                    $global:FunctionResult = "1"
                    return
                }
            }
        }
    }
}
    


##### END Initial Variable Definition and Validation #####

##### BEGIN Writing the Certificate Request Config File #####

# This content is saved to $CertGenWorking\$CertificateRequestConfigFile
# For more information about the contents of the config file, see: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx 

Set-Content -Value '[Version]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value 'Signature="$Windows NT$"' -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value '[NewRequest]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value "FriendlyName = $CertificateCN" -Path "$CertGenWorking\$CertificateRequestConfigFile"

# For below Subject, for a wildcard use "CN=*.DOMAIN.COM"
Add-Content -Value "Subject = `"CN=$CertificateCN,OU=$OrganizationalUnit,O=$Organization,L=$Locality,S=$State,C=$Country`"" -Path $CertGenWorking\$CertificateRequestConfigFile
if ($KeyLengthOverride -eq "Yes" -or $KeyLengthOverride -eq "y") {
    # Common key sizes: 512, 1024, 2048, 4096, 8192, 16384. Default is 2048
    Write-Host "Common key sizes are: 512, 1024, 2048, 4096, 8192, 16384"
    $KeyLength = Read-Host -Prompt "Please enter the KeyLength value you would like to use"
    Add-Content -Value "KeyLength = $KeyLength" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "KeyLength = $KeyLength" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($HashAlgorithmOverride -eq "Yes" -or $HashAlgorithmOverride -eq "y") {
    Write-Host ""
    Write-Host "Valid HashAlgorithm values are as follows"
    Write-Host ""
    [array]$ValidHashAlgorithmValues = (certutil -oid 1 | Select-String  pwszCNGAlgid) -replace "pwszCNGAlgid = ",""
    $ValidHashAlgorithmValues

    $HashAlgorithmValue = Read-Host -Prompt "Please enter the HashAlgorithm that you would like to use"
    Add-Content -Value "HashAlgorithm = $HashAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "HashAlgorithm = $HashAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
<#
# # KeyAlgorithm should be determined by ProviderName. Run "certutil -csplist" to see which Providers use which Key Algorithms
if ($KeyAlgorithmOverride -eq "Yes" -or $KeyAlgorithmOverride -eq "y") {
    Write-Host ""
    Write-Host "Valid KeyAlgorithm values are as follows"
    Write-Host ""
    $ValidKeyAlgorithmValues = @("RSA","DH","DSA","ECDH_P256","ECDH_P521","ECDSA_P256","ECDSA_P384","ECDSA_P521")
    $ValidKeyAlgorithmValues

    $KeyAlgorithmValue = Read-Host -Prompt "Please enter the KeyAlgorithm that you would like to use"
    Add-Content -Value "KeyAlgorithm = $KeyAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    if ($KeyAlgorithmValue -ne $null) {
        Add-Content -Value "KeyAlgorithm = $KeyAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    else {
        $KeyAlgorithmValue = "RSA"
        Add-Content -Value "KeyAlgorithm = $KeyAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
#>
if ($EncryptionAlgorithmOverride -eq "Yes" -or $EncryptionAlgorithmOverride -eq "y") {
    Write-Host ""
    Write-Host "Valid EncryptionAlgorithm values are as follows"
    Write-Host ""
    [array]$ValidEncryptionAlgorithmValues = (certutil -oid 2 | Select-String  pwszCNGAlgid) -replace "pwszCNGAlgid = ",""
    $ValidHashAlgorithmValues

    $EncryptionAlgorithmValue = Read-Host -Prompt "Please enter the HashAlgorithm that you would like to use"
    Add-Content -Value "EncryptionAlgorithm = $EncryptionAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "EncryptionAlgorithm = $EncryptionAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($PrivateKeyExportableOverride -eq "Yes" -or $PrivateKeyExportableOverride -eq "y") {
    $PrivKeyBool = Read-Host -Prompt "Would you like the private key to be exportable? [Yes/No]"
    # Validation check...
    if ($PrivKeyBool -eq "Yes" -or $PrivKeyBool -eq "y" -or $PrivKeyBool -eq "No" -or $PrivKeyBool -eq "n") {
        Write-Host "Value for PrivKeyBool Yes/No is valid...Continuing..."
    }
    else {
        Write-Host "The value for PrivKeyBool is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
        $global:FunctionResult = "1"
        return
    }
    if ($PrivKeyBool -eq "Yes" -or $PrivKeyBool -eq "y") {
        $PrivateKeyExportableValue = "TRUE"
        # Private key is exportable TRUE/FALSE
        Add-Content -Value "Exportable = $PrivateKeyExportableValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    if ($PrivKeyBool -eq "No" -or $PrivKeyBool -eq "n") {
        $PrivateKeyExportableValue = "FALSE"
        # Private key is exportable TRUE/FALSE
        Add-Content -Value "Exportable = $PrivateKeyExportableValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
else {
    Add-Content -Value "Exportable = $PrivateKeyExportableValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($KeySpecOverride -eq "Yes" -or $KeySpecOverride -eq "y") {
    $KeySpecValue = Read-Host -Prompt "Please enter the KeySpec value you would like to use.
    Valid values are '1' for AT_KEYEXCHANGE and '2' for AT_SIGNATURE [1,2]"
    # Validation check...
    if ($KeySpecValue -ne "1" -and $KeySpecValue -ne "2") {
        Write-Host "The value for PrivKeyBool is not valid. Please enter either 'TRUE' or 'FALSE'. Halting!"
        $global:FunctionResult = "1"
        return
    }
    else {
        # AT_KEYEXCHANGE which is KeySpec = 1 vs AT_SIGNATURE which is KeySpec = 2. 
        # Default is AT_KEYEXCHANGE which allows keys to be used for symmetric encryption or signing or both. Change only if you know what you're doing.
        Add-Content -Value "KeySpec = $KeySpecValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
else {
    Add-Content -Value "KeySpec = $KeySpecValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($KeyUsageOverride -eq "Yes" -or $KeyUsageOverride -eq "y") {
    $KeyUsageHexValue = Read-Host -Prompt "Please enter the HEXADECIMAL SUM of the KeyUsage hexadecimal values you would like to use.

    A valid value is the hex sum of one or more of following:
    CERT_DIGITAL_SIGNATURE_KEY_USAGE = 80; CERT_NON_REPUDIATION_KEY_USAGE 40; CERT_KEY_ENCIPHERMENT_KEY_USAGE 20;
    CERT_DATA_ENCIPHERMENT_KEY_USAGE 10; CERT_KEY_AGREEMENT_KEY_USAGE 8; CERT_KEY_CERT_SIGN_KEY_USAGE 4; 
    CERT_OFFLINE_CRL_SIGN_KEY_USAGE 2; CERT_CRL_SIGN_KEY_USAGE 2; CERT_ENCIPHER_ONLY_KEY_USAGE 1 
    
    Additional Notes - For AT_KEYEXCHANGE, EncipherOnly = TRUE: 30; For AT_KEYEXCHANGE, EncipherOnly = FALSE: f0; For AT_SIGNATURE (default) c0
    IMPORTANT: Some commonly used hex sums are 'c0' (i.e. 80+40), 'a0' (i.e. 80+20), and f0 (i.e. 80+40+20+10)"

    # Validation check...
    $ValidHexValues = @("1","10","11","12","13","14","15","16","17","18","2","20","21","22","23","24","25","26","27","28","3","30","38","4","40",`
    "41","42","43","44","45","46","47","48","5","50","58","6","60","68","7","70","78","8","80","81","82","83","84","85","86","87","88","9","90",`
    "98","a","a0","a8","b","b0","b8","c","c0","c","8","d","d0","d8","e","e0","e8","f","f0","f8")
 
    # If hex value provided by user to $KeyUsagehexValue is not valid, halt script 
    if ($ValidHexValues -notcontains $KeyUsageHexValue) {
        Write-Host "$($KeyUsageHexValue) is not a valid hexadecimal value for KeyUsage. Please use 80,40,20,10,8,4,2,1, or any HEXADECIMAL SUM of the aforementioned."
        $KeyUsageHexValue = Read-Host -Prompt "Please enter the HEXADECIMAL SUM of the KeyUsage hexadecimal values you would like to use.

        A valid value is the hex sum of one or more of following:
        CERT_DIGITAL_SIGNATURE_KEY_USAGE = 80; CERT_NON_REPUDIATION_KEY_USAGE 40; CERT_KEY_ENCIPHERMENT_KEY_USAGE 20;
        CERT_DATA_ENCIPHERMENT_KEY_USAGE 10; CERT_KEY_AGREEMENT_KEY_USAGE 8; CERT_KEY_CERT_SIGN_KEY_USAGE 4; 
        CERT_OFFLINE_CRL_SIGN_KEY_USAGE 2; CERT_CRL_SIGN_KEY_USAGE 2; CERT_ENCIPHER_ONLY_KEY_USAGE 1 
    
        Additional Notes - For AT_KEYEXCHANGE, EncipherOnly = TRUE: 30; For AT_KEYEXCHANGE, EncipherOnly = FALSE: f0; For AT_SIGNATURE (default) C0
        IMPORTANT: Some commonly used hex sums are 'c0' (i.e. 80+40), 'a0' (i.e. 80+20), and f0 (i.e. 80+40+20+10)"
        if ($ValidHexValues -notcontains $KeyUsageHexValue) {
            Write-Host "$($KeyUsageHexValue) is not a valid hexadecimal value for KeyUsage. Halting!"
            $global:FunctionResult = "1"
            return
        }
    }
    else {
        $KeyUsageValue = '0x'+$KeyUsageHexValue  
        Add-Content -Value "KeyUsage = $KeyUsageValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
else {
    Add-Content -Value "KeyUsage = $KeyUsageValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}

# MachineKeySet = TRUE/FALSE. You must set this key to TRUE if you are creating requests for domain controllers,
# a Web server, or any other service that runs in the Computer’s security context (as opposed to a User security context).
Add-Content -Value "MachineKeySet = $MachineKeySet" -Path "$CertGenWorking\$CertificateRequestConfigFile"

if ($SecureEmail -eq "Yes" -or $SecureEmail -eq "y") {
    Write-Host ""
    Write-Host "Setting KeySpec = 2 and SMIME = TRUE"
    Write-Host ""
    $KeySpecValue = 2
    $SMIMEValue = "TRUE"
    # SMIME = TRUE/FALSE. If TRUE, certificate can be used for Secure E-mail.  If KeySpec = 1, then SMIME MUST be FALSE.
    Add-Content -Value "SMIME = $SMIMEValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    (Get-Content "$CertGenWorking\$CertificateRequestConfigFile" | Foreach-Object {$_ -replace '^KeySpec =.+$', "KeySpec = $KeySpecValue"}) | Set-Content "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    if ($SMIMEValue -ne $null) {
        Add-Content -Value "SMIME = $SMIMEValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    else {
        $SMIMEValue = "FALSE"
        # SMIME = TRUE/FALSE. If TRUE, certificate can be used for Secure E-mail.  If KeySpec = 1, then SMIME MUST be FALSE
        Add-Content -Value "SMIME = $SMIMEValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}

Add-Content -Value 'PrivateKeyArchive = FALSE' -Path "$CertGenWorking\$CertificateRequestConfigFile"

if ($UserProtected -eq "Yes" -or $UserProtected -eq "y") {
    Write-Host ""
    Write-Host "Setting UserProtected = TRUE and MachineKeySet = FALSE"
    Write-Host ""
    $UserProtectedValue = "TRUE"
    $MachineKeySet = "FALSE"
    # If UserProtected = TRUE, the key is protected with a password, and you must enter this password every time the key is accessed
    # If using the certificate under Computer security context (i.e. MachineKeySet = TRUE), then UserProtected should be FALSE
    Add-Content -Value "UserProtected = $UserProtectedValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    (Get-Content "$CertGenWorking\$CertificateRequestConfigFile" | Foreach-Object {$_ -replace '^MachineKeySet =.+$', "MachineKeySet = $machineKeySet"}) | Set-Content $CertGenWorking\$CertificateRequestConfigFile
}
else {
    if ($UserProtectedValue -ne $null) {
        Add-Content -Value "UserProtected = $UserProtectedValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    else {
        $UserProtectedValue = "FALSE"
        # If UserProtected = TRUE, the key is protected with a password, and you must enter this password every time the key is accessed
        # If using the certificate under Computer security context (i.e. MachineKeySet = TRUE), then UserProtected should be FALSE
        Add-Content -Value "UserProtected = $UserProtectedValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}

Add-Content -Value 'UseExistingKeySet = FALSE' -Path "$CertGenWorking\$CertificateRequestConfigFile"

if ($ProviderNameOverride -eq "Yes" -or $ProviderNameOverride -eq "y") {
    Write-Host ""
    Write-Host "All available Cryptographic Providers (CSPs) are as follows:"
    Write-Host ""
    $PossibleProvidersPrep = certutil -csplist | Select-String "Provider Name" -Context 0,1
    $PossibleProviders = foreach ($obj1 in $PossibleProvidersPrep) {
        $obj2 = $obj1.Context.PostContext | Select-String 'FAIL' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Success
        $obj3 = $obj1.Context.PostContext | Select-String 'not ready' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Success
        if ($obj2 -ne "True" -and $obj3 -ne "True") {
            $obj1.Line -replace "Provider Name: ",""
        }
    }
    $PossibleProviders
    Write-Host ""
    Write-Host "Available Cryptographic Providers (CSPs) based on your choice in Certificate Template (i.e. $($BasisTemplate)) are as follows:"
    Write-Host ""
    $AvailableCSPsBasedOnCertificateTemplate = (Get-ADObject $CertificateTemplateLDAPObject -Properties * | Select-Object -ExpandProperty pkiDefaultCSPs) -replace '[0-9],',''
    $AvailableCSPsBasedOnCertificateTemplate
    # NOTE: There can only be one (1) ProviderNameValue. Maybe no need to use array.
    $ProviderNameValuePrep = $(Read-Host -Prompt "Please enter the name of the Cryptographic Provider (CSP) you would like to use")
    $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
    # Validation check...
    foreach ($obj1 in $ProviderNameValue) {
        if ($AvailableCSPsBasedOnCertificateTemplate -notcontains $obj1) {
            Write-Host "$($obj1) is not a valid ProviderNameValue. Valid Provider Names based on your choice in Basis Certificate Template are as follows:"
            $AvailableCSPsBasedOnCertificateTemplate
            $ProviderNameValuePrep = $(Read-Host -Prompt "Please enter the name of the Cryptographic Provider (CSP) you would like to use")
            $ProviderNameValue = $ProviderNameValuePrep.Split(",").Trim()
            # Validation check...
            foreach ($obj1 in $ProviderNameValue) {
                if ($AvailableCSPsBasedOnCertificateTemplate -notcontains $obj1) {
                    Write-Host "$($obj1) is not a valid ProviderNameValue. Halting!"
                    $global:FunctionResult = "1"
                    return
                }
            }
        }
    }
    Add-Content -Value "ProviderName = `"$ProviderNameValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    
    # Next, get the $ProviderTypeValue based on $ProviderNameValue
    $ProviderTypeValuePrep = certutil -csplist | Select-String $ProviderNameValue -Context 0,1
    $ProviderTypeValue = $ProviderTypeValuePrep.Context.PostContext | Select-String -Pattern '[0-9]{1,2}' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    Add-Content -Value "ProviderType = `"$ProviderTypeValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "ProviderName = `"$ProviderNameValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    $ProviderTypeValuePrep = certutil -csplist | Select-String $ProviderNameValue -Context 0,1
    $ProviderTypeValue = $ProviderTypeValuePrep.Context.PostContext | Select-String -Pattern '[0-9]{1,2}' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    Add-Content -Value "ProviderType = `"$ProviderTypeValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}

if ($RequestTypeOverride -eq "Yes" -or $RequestTypeOverride -eq "y") {
    # TODO: Valid RequestType options are CMC, PKCS10, PKCS10-, PKCS7, and Cert
    # HOWEVER, the "Cert" RequestType indicates a self-signed or self-issued certificate. It does NOT generate a request, but rather a new certificate
    # and then installs the certificate. To create a self-issued certificate that is NOT self-signed, specify a signing cert by using the –cert option 
    # in the certreq.exe command. For this to work, you must 1) add "Cert" to the below $ValidRequestTypes array. 2) Uncomment 
    # the below 'if' statement: if ($RequestTypeValue -eq "Cert"), 3) Uncomment the "certreq -new -cert ..." command, 4) Comment the original 
    # "certreq -new ..." command, and 5) Comment the "certreq submit ..." command
    Write-Host ""
    Write-Host "Available RequestType values are as follows:"
    $ValidRequestTypes = @("CMC", "PKCS10", "PKCS10-", "PKCS7")
    $ValidRequestTypes
    $RequestTypeValue = $(Read-Host -Prompt "Please enter the RequestType value you would like to use")
    # Validation check...
    if ($ValidRequestTypes -notcontains $RequestTypeValue) {
        Write-Host "The RequestType value is not valid. Please choose a RequestType value from the list of available RequestType values. halting!"
        $global:FunctionResult = "1"
        return
    }
    
    # Add RequestType format  
    Add-Content -Value "RequestType = $RequestTypeValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "RequestType = $RequestTypeValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
<#
TODO: Logic for self-signed and/or self-issued certificates that DO NOT generate a CSR and DO NOT submit to Certificate Authority
if ($RequestTypeValue -eq "Cert") {
    $ValidityPeriodValue = Read-Host -Prompt "Please enter the length of time that the certificate will be valid for.
    #NOTE: Values must be in Months or Years. For example '6 months' or '2 years'"
    $ValidityPeriodPrep = $ValidityPeriodValue.Split(" ") | Select-Object -Index 1
    if ($ValidityPeriodPrep.EndsWith("s")) {
        $ValidityPeriod = $ValidityPeriodPrep.substring(0,1).toupper()+$validityPeriodPrep.substring(1).tolower()
    }
    else {
        $ValidityPeriod = $ValidityPeriodPrep.substring(0,1).toupper()+$validityPeriodPrep.substring(1).tolower()+'s'
    }
    $ValidityPeriodUnits = $ValidityPeriodValue.Split(" ") | Select-Object -Index 0

    Add-Content -Value "ValidityPeriodUnits = $ValidityPeriodUnits" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    Add-Content -Value "ValidityPeriod = $ValidityPeriod" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
#>

if ($IntendedPurposeOverride -eq "Yes" -or $IntendedPurposeOverride -eq "y") {
    Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    Add-Content -Value '[Strings]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
    Add-Content -Value 'szOID_ENHANCED_KEY_USAGE = "2.5.29.37"' -Path "$CertGenWorking\$CertificateRequestConfigFile"
    if ($IntendedPurposeValuesPrep -eq $null) {
        Write-Host ""
        Write-Host "Your new Certificate Template must have one or more Intended Purposes"
        $ChangeTemplateIntendedPurposes = Read-Host -Prompt "Would you like to set Intended Purposes for the New Certificate that differ from those
        defined in the Basis Template $BasisTemplate ? [Yes\No]"
        if ($ChangeTemplateIntendedPurposes -eq "Yes" -or $ChangeTemplateIntendedPurposes -eq "y") {
            Write-Host "Valid Intended Purpose values are as follows:"
            Write-Host ""
            $ValidIntendedPurposeValuesString
            Write-Host ""
            [array]$IntendedPurposeValuesPrep = Read-Host -Prompt "Please enter one (or more) Intended Purpose values separated by commas"
        }
        else {
            Write-Host "Using Intended Purpose Values from the Basis Certificate Template $BasisTemplate"
        }
    }
    if ($IntendedPurposeValuesPrep -ne $null) {
        $IntendedPurposeValues = $IntendedPurposeValuesPrep.Split(",").Trim()
        # Validation check...
        foreach ($obj1 in $IntendedPurposeValues) {
            if ($ValidIntendedPurposeValues -notcontains $obj1) {
                Write-Host "$($obj1) is not a valid IntendedPurpose. Halting!"
                Write-Host "Valid IntendedPurpose values are as follows:"
                $ValidIntendedPurposeValuesString
                $global:FunctionResult = "1"
                return
            }
        }

        Get-IntendedPurposeAdjudication

        foreach ($obj1 in $CertRequestConfigFileStringsSectionArray) {
            Add-Content -Value "$obj1" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        }

        Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        Add-Content -Value '[Extensions]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
        $szOIDArrayFirstItem = $szOIDArray[0]
        Add-Content -Value "%szOID_ENHANCED_KEY_USAGE%=`"{text}%$szOIDArrayFirstItem%,`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        $szOIDArray.RemoveAt(0)
        foreach ($obj1 in $szOIDArray) {
            Add-Content -Value "_continue_ = `"%$obj1%`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        }
    }
}
else {
    if ($IntendedPurposeValuesPrep -eq $null) {
        Write-Host "Using Intended Purpose Values from the Basis Certificate Template $BasisTemplate"
    }
    if ($IntendedPurposeValuesPrep -ne $null) {
        Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        Add-Content -Value '[Strings]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
        Add-Content -Value 'szOID_ENHANCED_KEY_USAGE = "2.5.29.37"' -Path "$CertGenWorking\$CertificateRequestConfigFile"
        $IntendedPurposeValues = $IntendedPurposeValuesPrep.Split(",").Trim()
        # Validation check...
        foreach ($obj1 in $IntendedPurposeValues) {
            if ($ValidIntendedPurposeValues -notcontains $obj1) {
                Write-Host "$($obj1) is not a valid IntendedPurpose. Halting!"
                Write-Host "Valid IntendedPurpose values are as follows:"
                $ValidIntendedPurposeValuesString
                $global:FunctionResult = "1"
                return
            }
        }

        Get-IntendedPurposeAdjudication

        foreach ($obj1 in $CertRequestConfigFileStringsSectionArray) {
            Add-Content -Value "$obj1" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        }

        Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        Add-Content -Value '[Extensions]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
        $szOIDArrayFirstItem = $szOIDArray[0]
        Add-Content -Value "%szOID_ENHANCED_KEY_USAGE%=`"{text}%$szOIDArrayFirstItem%,`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        $szOIDArray.RemoveAt(0)
        foreach ($obj1 in $szOIDArray) {
            Add-Content -Value "_continue_ = `"%$obj1%`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
        }
    }
}

if ($AddSAN -eq "Yes" -or $AddSAN -eq "y") {
    Add-Content -Value '2.5.29.17 = "{text}"' -Path "$CertGenWorking\$CertificateRequestConfigFile"
    
    $ValidSANObjectTypes = @("DNS","Distinguished Name","URL","IP Address","Email","UPN","GUID")
    $ValidSANObjectTypesAsStringPrep = foreach ($obj1 in $ValidSANObjectTypes) {
        $obj1.Trim()+','
    }
    $ValidSANObjectTypesAsString = [string]$ValidSANObjectTypesAsStringPrep

    if ($TypesofSANObjectsToAdd -eq $null) {
        Write-Host "Please specify the types of SAN Objects that you would like to add to the New Certificate."
        Write-Host "Valid options are as follows:"
        $ValidSANObjectTypesAsString

        $TypesofSANObjectsToAdd = Read-Host -Prompt "Which types of SAN Objects would you like to add?
        For multiple types, simply separate with a comma. Example: DNS, IP Address, Email"
    }

    $TypesofSANObjectsToAddArray = $TypesofSANObjectsToAdd.Split(",").Trim()

    foreach ($obj1 in $TypesofSANObjectsToAddArray) {
        if ($obj1 -eq "DNS") {
            if ($DNSSANObjects -eq $null) {
                $DNSSANObjects = Read-Host -Prompt "Please enter one or more DNS SAN objects separated by commas
                Example: www.fabrikam.com, www.contoso.org"
            }
            $DNSSANObjectsArray = $DNSSANObjects.Split(",").Trim()
            foreach ($obj2 in $DNSSANObjectsArray) {
                Add-Content -Value "_continue_ = `"dns=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
        if ($obj1 -eq "Distinguished Name") {
            if ($DistinguishedNameSANObjects -eq $null) {
                $DistinguishedNameSANObjects = Read-Host -Prompt "Please enter one or more Distinguished Name SAN objects ***separated by semi-colons***
                Example: CN=www01,OU=Web Servers,DC=fabrikam,DC=com; CN=www01,OU=Load Balancers,DC=fabrikam,DC=com"
            }
            $DistinguishedNameSANObjectsArray = $DistinguishedNameSANObjects.Split(";").Trim()
            foreach ($obj2 in $DistinguishedNameSANObjectsArray) {
                Add-Content -Value "_continue_ = `"dn=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
        if ($obj1 -eq "URL") {
            if ($URLSANObjects -eq $null) {
                $URLSANObjects = Read-Host -Prompt "Please enter one or more URL SAN objects separated by commas
                Example: http://www.fabrikam.com, http://www.contoso.com"
            }
            $URLSANObjectsArray = $URLSANObjects.Split(",").Trim()
            foreach ($obj2 in $URLSANObjectsArray) {
                Add-Content -Value "_continue_ = `"url=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
        if ($obj1 -eq "IP Address") {
            if ($IPAddressSANObjects -eq $null) {
                $IPAddressSANObjects = Read-Host -Prompt "Please enter one or more IP Address SAN objects separated by commas
                Example: 172.31.10.13, 192.168.2.125"
            }
            $IPAddressSANObjectsArray = $IPAddressSANObjects.Split(",").Trim()
            foreach ($obj2 in $IPAddressSANObjectsArray) {
                Add-Content -Value "_continue_ = `"ipaddress=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
        if ($obj1 -eq "Email") {
            if ($EmailSANObjects -eq $null) {
                $EmailSANObjects = Read-Host -Prompt "Please enter one or more Email SAN objects separated by commas
                Example: mike@fabrikam.com, hazem@fabrikam.com"
            }
            $EmailSANObjectsArray = $EmailSANObjects.Split(",").Trim()
            foreach ($obj2 in $EmailSANObjectsArray) {
                Add-Content -Value "_continue_ = `"email=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
        if ($obj1 -eq "UPN") {
            if ($UPNSANObjects -eq $null) {
                $UPNSANObjects = Read-Host -Prompt "Please enter one or more UPN SAN objects separated by commas
                Example: mike@fabrikam.com, hazem@fabrikam.com"
            }
            $UPNSANObjectsArray = $UPNSANObjects.Split(",").Trim()
            foreach ($obj2 in $UPNSANObjectsArray) {
                Add-Content -Value "_continue_ = `"upn=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
        if ($obj1 -eq "GUID") {
            if ($GUIDSANObjects -eq $null) {
                $GUIDSANObjects = Read-Host -Prompt "Please enter one or more GUID SAN objects separated by commas
                Example: f7c3ac41-b8ce-4fb4-aa58-3d1dc0e36b39, g8D4ac41-b8ce-4fb4-aa58-3d1dc0e47c48"
            }
            $GUIDSANObjectsArray = $GUIDSANObjects.Split(",").Trim()
            foreach ($obj2 in $GUIDSANObjectsArray) {
                Add-Content -Value "_continue_ = `"guid=$obj2&`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
            }
        }
    }
}

##### END Writing the Certificate Request Config File #####


##### BEGIN Generate Certificate Request and Submit to Issuing Certificate Authority #####

## Generate new Certificate Request File: ##
# NOTE: The generation of a Certificate Request File using the below "certreq.exe -new" command also adds the CSR to the 
# Client Machine's Certificate Request Store located at PSDrive "Cert:\CurrentUser\REQUEST" which is also known as 
# "Microsoft.PowerShell.Security\Certificate::CurrentUser\Request"
# There doesn't appear to be an equivalent to this using PowerShell cmdlets
certreq.exe -new "$CertGenWorking\$CertificateRequestConfigFile" "$CertGenWorking\$CertificateRequestFile"
# TODO: If the Certificate Request Configuration File referenced in the above command contains "RequestType = Cert", then instead of the above command, 
# the below certreq command should be used:
# certreq.exe -new -cert [CertId] "$CertGenWorking\$CertificateRequestConfigFile" "$CertGenWorking\$CertificateRequestFile"

if ($RequestViaWebEnrollment -eq "Yes" -or $RequestViaWebEnrollment -eq "y") {
    # POST Data as a hash table
    $postParams = @{            
        "Mode"             = "newreq"
        "CertRequest"      = $(Get-Content "$CertGenWorking\$CertificateRequestFile" -Encoding Ascii | Out-String)
        "CertAttrib"       = "CertificateTemplate:$BasisTemplate"
        "FriendlyType"     = "Saved-Request+Certificate+($(Get-Date -DisplayHint Date -Format M/dd/yyyy),+$(Get-Date -DisplayHint Date -Format h:mm:ss+tt))"
        "Thumbprint"       = ""
        "TargetStoreFlags" = "0"
        "SaveCert"         = "yes"
    }

    # Submit New Certificate Request and Download New Certificate
    if ($ADCSWebAuthType -like "*Windows*") {
        # Send the POST Data
        Invoke-RestMethod -Uri "$ADCSWebEnrollmentURL/certfnsh.asp" -Method Post -Body $postParams -Credential $ADCSWebCreds -OutFile "$CertGenWorking\$CertADCSWebResponse"
    
        # Download New Certificate
        $ReqId = (Get-Content "$CertGenWorking\$CertADCSWebResponse" | Select-String -Pattern "ReqID=[0-9]{1,5}" | Select-Object -Index 0).Matches.Value.Split("=")[1]
        if ($ReqId -eq $null) {
            Write-Host "The Certificate Request was successfully submitted via ADCS Web Enrollment, but was rejected. Please check the format and contents of
            the Certificate Request Config File and try again."
            $global:FunctionResult = "1"
            return
        }

        $CertWebRawContent = (Invoke-WebRequest -Uri "$ADCSWebEnrollmentURL/certnew.cer?ReqID=$ReqId&Enc=b64" -Credential $ADCSWebCreds).RawContent
        # Replace the line that begins with `r with ;;; then split on ;;; and select the last object in the index
        (($CertWebRawContent.Split("`n") -replace "^`r",";;;") -join "`n").Split(";;;")[-1].Trim() | Out-File "$CertGenWorking\$CertFileOut"
        # Alternate: Skip everything up until `r
        #$CertWebRawContent.Split("`n") | Select-Object -Skip $([array]::indexof($($CertWebRawContent.Split("`n")),"`r")) | Out-File "$CertGenWorking\$CertFileOut"
    }
    if ($ADCSWebAuthType -like "*Basic*") {
        # Send the POST Data
        Invoke-RestMethod -Uri "$ADCSWebEnrollmentURL/certfnsh.asp" -Method Post -Body $postParams -Headers $headers -OutFile "$CertGenWorking\$CertADCSWebResponse"

        # Download New Certificate
        $ReqId = (Get-Content "$CertGenWorking\$CertADCSWebResponse" | Select-String -Pattern "ReqID=[0-9]{1,5}" | Select-Object -Index 0).Matches.Value.Split("=")[1]
        if ($ReqId -eq $null) {
            Write-Host "The Certificate Request was successfully submitted via ADCS Web Enrollment, but was rejected. Please check the format and contents of
            the Certificate Request Config File and try again."
            $global:FunctionResult = "1"
            return
        }

        $CertWebRawContent = (Invoke-WebRequest -Uri "$ADCSWebEnrollmentURL/certnew.cer?ReqID=$ReqId&Enc=b64" -Headers $headers).RawContent
        $CertWebRawContentArray = $CertWebRawContent.Split("`n") 
        $CertWebRawContentArray | Select-Object -Skip $([array]::indexof($CertWebRawContentArray,"`r")) | Out-File "$CertGenWorking\$CertFileOut"
    }
}

if ($RequestViaWebEnrollment -eq "No" -or $RequestViaWebEnrollment -eq "n") {
    ## Submit New Certificate Request File to Issuing Certificate Authority and Specify a Certificate to Use as a Base ##
    if (Test-Path "$CertGenWorking\$CertificateRequestFile") {
        certreq.exe -submit -attrib "CertificateTemplate:$cnForBasisTemplate" -config "$IssuingCertAuth" "$CertGenWorking\$CertificateRequestFile" "$CertGenWorking\$CertFileOut" "$CertGenWorking\$CertificateChainOut"
        # Equivalent of above certreq command using "Get-Certificate" cmdlet is below. We decided to use certreq.exe though because it actually outputs
        # files to the filesystem as opposed to just working with the client machine's certificate store.  This is more similar to the same process on Linux.
        #
        # ## Begin "Get-Certificate" equivalent ##
        # $LocationOfCSRInStore = $(Get-ChildItem Cert:\CurrentUser\Request | Where-Object {$_.Subject -like "*$CertificateCN*"}) | Select-Object -ExpandProperty PSPath
        # Get-Certificate -Template $cnForBasisTemplate -Url "https:\\$IssuingCertAuthFQDN\certsrv" -Request $LocationOfCSRInStore -CertStoreLocation Cert:\CurrentUser\My
        # NOTE: The above Get-Certificate command ALSO imports the certificate generated by the above request, making the below "Import-Certificate" command unnecessary
        # ## End "Get-Certificate" equivalent ##
    }
}
    
if (Test-Path "$CertGenWorking\$CertFileOut") {
    ## Generate .pfx file by installing certificate in store and then exporting with private key ##
    # NOTE: I'm not sure why importing a file that only contains the public certificate (i.e, the .cer file) suddenly makes the private key available
    # in the Certificate Store. It just works for some reason...
    # First, install the public certificate in store
    Import-Certificate -FilePath "$CertGenWorking\$CertFileOut" -CertStoreLocation Cert:\CurrentUser\My
    # certreq.exe equivalent of the above Import-Certificate command is below. It is not as reliable as Import-Certifcate.
    # certreq -accept -user "$CertGenWorking\$CertFileOut"     

    # Then, export cert with private key in the form of a .pfx file
    if ($MachineKeySet -eq "FALSE") {
        Sleep 5
        $LocationOfCertInStore = $(Get-ChildItem Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*CN=$CertificateCN*"}) | Select-Object -ExpandProperty PSPath
        if ($LocationOfCertInStore.Count -gt 1) {
            Write-Host ""
            Write-Host "Writing LocationofCertInStore"
            Write-Host ""
            $LocationOfCertInStore
            Write-Host ""
            Write-Host "You have more than one certificate in your Certificate Store under Cert:\CurrentUser\My with the same Common Name (CN). Please correct this and try again."
            $global:FunctionResult = "1"
            return
        }
        Sleep 5
        Export-PfxCertificate -Cert $LocationOfCertInStore -FilePath "$CertGenWorking\$PFXFileOut" -Password $PFXPwdAsSecureString
        # Equivalent of above using certutil
        # $ThumbprintOfCertToExport = $(Get-ChildItem Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*$CertificateCN*"}) | Select-Object -ExpandProperty Thumbprint
        # certutil -exportPFX -p "$PFXPwdPlainText" my $ThumbprintOfCertToExport "$CertGenWorking\$PFXFileOut"

        if ($UseOpenSSL -eq "Yes" -or $UseOpenSSL -eq "y") {
            if (! (Test-Path $PathToWin32OpenSSL)) {
                $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the path to the Win32 OpenSSL binary directory"
                if (Test-Path $PathToWin32OpenSSL) {
                    Write-Host "Path to Win32 OpenSSL directory is valid...Continuing..."
                }
                else {
                    Write-Host "Win32 OpenSSL binary directory not found"
                    $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the path to the Win32 OpenSSL binary directory"
                    if (Test-Path $PathToWin32OpenSSL) {
                        cd $PathToWin32OpenSSL
                    }
                    else {
                        Write-Host "Win32 OpenSSL binary directory not found. Halting!"
                        $global:FunctionResult = "1"
                        return
                    }
                }
                cd $PathToWin32OpenSSL
            }
            else {
                cd $PathToWin32OpenSSL
            }

            # OpenSSL can't handle PowerShell SecureStrings, so need to convert it back into Plain Text
            $PwdForPFXOpenSSL = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($PFXPwdAsSecureString))

            # Extract Private Key and Keep It Password Protected
            & "$PathToWin32OpenSSL\openssl.exe" pkcs12 -in "$CertGenWorking\$PFXFileOut" -nocerts -out "$CertGenWorking\$ProtectedPrivateKeyOut" -nodes -password pass:$PwdForPFXOpenSSL 2>&1 | Out-Null

            # The .pfx File Contains ALL Public Certificates in Chain 
            # The below extracts ALL Public Certificates in Chain
            & "$PathToWin32OpenSSL\openssl.exe" pkcs12 -in "$CertGenWorking\$PFXFileOut" -nokeys -out "$CertGenWorking\$AllPublicKeysInChainOut" -password pass:$PwdForPFXOpenSSL 2>&1 | Out-Null

            # Parse the Public Certificate Chain File and and Write Each Public Certificate to a Separate File
            # These files should have the EXACT SAME CONTENT as the .cer counterparts
            $PublicKeySansChainPrep1 = Get-Content "$CertGenWorking\$AllPublicKeysInChainOut"
            $LinesToReplace1 = $PublicKeySansChainPrep1 | Select-String -Pattern "issuer" | Sort-Object | Get-Unique
            $LinesToReplace2 = $PublicKeySansChainPrep1 | Select-String -Pattern "Bag Attributes" | Sort-Object | Get-Unique
            $PublicKeySansChainPrep2 = (Get-Content "$CertGenWorking\$AllPublicKeysInChainOut") -join "`n"
            foreach ($obj1 in $LinesToReplace1) {
                $PublicKeySansChainPrep2 = $PublicKeySansChainPrep2 -replace "$obj1",";;;"
            }
            foreach ($obj1 in $LinesToReplace2) {
                $PublicKeySansChainPrep2 = $PublicKeySansChainPrep2 -replace "$obj1",";;;"
            }
            $PublicKeySansChainPrep3 = $PublicKeySansChainPrep2.Split(";;;")
            $PublicKeySansChainPrep4 = foreach ($obj1 in $PublicKeySansChainPrep3) {
                if ($obj1.Trim().StartsWith("-")) {
                    $obj1.Trim()
                }
            }
            # Setup Hash Containing Cert Name vs Content Pairs
            $CertNamevsContentsHash = @{}
            foreach ($obj1 in $PublicKeySansChainPrep4) {
                $obj2 = $obj1.Split("`n")[1]
                if ((($PublicKeySansChainPrep1 | Select-String -SimpleMatch $obj2).Line) -ne $null) {
                    $CertNamePrep = (($PublicKeySansChainPrep1 | Select-String -SimpleMatch $obj2 -Context 4).Context.PreContext | Select-String -Pattern "subject").Line
                    $CertName = $CertNamePrep.Split("=") | Select-Object -Last 1
                    $CertNamevsContentsHash.Add("$CertName", "$obj1")
                }
            }

            # Write each Hash Key Value to Separate Files (i.e. writing all public keys in chain to separate files)
            foreach ($obj1 in $CertNamevsContentsHash.Keys) {
                $CertNamevsContentsHash.$obj1 | Out-File "$CertGenWorking\$obj1`_Public_Cert.pem" -Encoding Ascii
            }

            # Determine if we should remove the password from the private key (i.e. $ProtectedPrivateKeyOut)
            if ($StripPrivateKeyOfPassword -eq $null) {
                $StripPrivateKeyOfPassword = Read-Host -Prompt "Would you like to remove password protection from the private key? [Yes/No]"
                if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y" -or $StripPrivateKeyOfPassword -eq "No" -or $StripPrivateKeyOfPassword -eq "n") {
                    Write-Host "The value for StripPrivateKeyOfPassword is valid...continuing"
                }
                else {
                    Write-Host "The value for StripPrivateKeyOfPassword is not valid. Please enter either 'Yes', 'y', 'No', or 'n'."
                    $StripPrivateKeyOfPassword = Read-Host -Prompt "Would you like to remove password protection from the private key? [Yes/No]"
                    if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y" -or $StripPrivateKeyOfPassword -eq "No" -or $StripPrivateKeyOfPassword -eq "n") {
                        Write-Host "The value for StripPrivateKeyOfPassword is valid...continuing"
                    }
                    else {
                        Write-Host "The value for StripPrivateKeyOfPassword is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
                        $global:FunctionResult = "1"
                        return
                    }
                }
                if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y") {
                    # Strip Private Key of Password
                    & "$PathToWin32OpenSSL\openssl.exe" rsa -in "$CertGenWorking\$ProtectedPrivateKeyOut" -out "$CertGenWorking\$UnProtectedPrivateKeyOut" 2>&1 | Out-Null
                }
            }
            if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y") {
                # Strip Private Key of Password
                & "$PathToWin32OpenSSL\openssl.exe" rsa -in "$CertGenWorking\$ProtectedPrivateKeyOut" -out "$CertGenWorking\$UnProtectedPrivateKeyOut" 2>&1 | Out-Null
            }
        }
    }
}

# Create Global HashTable of Outputs for use in scripts that source this script
$GenerateCertificateFileOutputHashGlobal = @{}
$GenerateCertificateFileOutputHashGlobal.Add("CertificateRequestConfigFile", "$CertificateRequestConfigFile")
$GenerateCertificateFileOutputHashGlobal.Add("CertificateRequestFile", "$CertificateRequestFile")
$GenerateCertificateFileOutputHashGlobal.Add("CertFileOut", "$CertFileOut")
if ($MachineKeySet -eq "FALSE") {
    $GenerateCertificateFileOutputHashGlobal.Add("PFXFileOut", "$PFXFileOut")
}
if ($RequestViaWebEnrollment -eq "No" -or $RequestViaWebEnrollment -eq "n") {
    $CertUtilResponseFile = (Get-Item "$CertGenWorking\*.rsp").Name
    $GenerateCertificateFileOutputHashGlobal.Add("CertUtilResponseFile", "$CertUtilResponseFile")

    $GenerateCertificateFileOutputHashGlobal.Add("CertificateChainOut", "$CertificateChainOut")
}
if ($RequestViaWebEnrollment -eq "Yes" -or $RequestViaWebEnrollment -eq "y") {
    $GenerateCertificateFileOutputHashGlobal.Add("CertADCSWebResponse", "$CertADCSWebResponse")
}
if ($UseOpenSSL -eq "Yes" -or $UseOpenSSL -eq "y") {
    $GenerateCertificateFileOutputHashGlobal.Add("AllPublicKeysInChainOut", "$AllPublicKeysInChainOut")

    # Make CertName vs Contents Key/Value Pair hashtable available to scripts that source this script
    $CertNamevsContentsHashGlobal = $CertNamevsContentsHash

    $AdditionalPublicKeysArray = (Get-Item "$CertGenWorking\*_Public_Cert.pem").Name
    # For each Certificate in the hashtable $CertNamevsContentsHashGlobal, determine it it's a Root, Intermediate, or End Entity
    foreach ($obj1 in $AdditionalPublicKeysArray) {
        $SubjectType = (certutil -dump $CertGenWorking\$obj1 | Select-String -Pattern "Subject Type=").Line.Split("=")[-1]
        $RootCertFlag = certutil -dump $CertGenWorking\$obj1 | Select-String -Pattern "Subject matches issuer"
        $EndPointCNFlag = certutil -dump $CertGenWorking\$obj1 | Select-String -Pattern "CN=$CertificateCN"
        if ($SubjectType -eq "CA" -and $RootCertFlag.Matches.Success -eq $true) {
            $RootCAPublicCertFile = $obj1
            $GenerateCertificateFileOutputHashGlobal.Add("RootCAPublicCertFile", "$RootCAPublicCertFile")
        }
        if ($SubjectType -eq "CA" -and $RootCertFlag.Matches.Success -ne $true) {
            $IntermediateCAPublicCertFile = $obj1
            $GenerateCertificateFileOutputHashGlobal.Add("IntermediateCAPublicCertFile", "$IntermediateCAPublicCertFile")
        }
        if ($SubjectType -eq "End Entity" -and $EndPointCNFlag.Matches.Success -eq $true) {
            $EndPointPublicCertFile = $obj1
            $GenerateCertificateFileOutputHashGlobal.Add("EndPointPublicCertFile", "$EndPointPublicCertFile")
        }
    }

    # Alternate Logic using .Net to Inspect Certificate files to Determine RootCA, Intermediate CA, and Endpoint
    <#
    foreach ($obj1 in $AdditionalPublicKeysArray) {
        $certPrint = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
        $certPrint.Import("$CertGenWorking\$obj1")
        if ($certPrint.Issuer -eq $certPrint.Subject) {
            $RootCAPublicCertFile = $obj1
            $RootCASubject = $certPrint.Subject
            $GenerateCertificateFileOutputHashGlobal.Add("RootCAPublicCertFile", "$RootCAPublicCertFile")
        }
    }
    foreach ($obj1 in $AdditionalPublicKeysArray) {
        $certPrint = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
        $certPrint.Import("$CertGenWorking\$obj1")
        if ($certPrint.Issuer -eq $RootCASubject -and $certPrint.Subject -ne $RootCASubject) {
            $IntermediateCAPublicCertFile = $obj1
            $IntermediateCASubject = $certPrint.Subject
            $GenerateCertificateFileOutputHashGlobal.Add("IntermediateCAPublicCertFile", "$IntermediateCAPublicCertFile")
        }
    }
    foreach ($obj1 in $AdditionalPublicKeysArray) {
        $certPrint = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
        $certPrint.Import("$CertGenWorking\$obj1")
        if ($certPrint.Issuer -eq $IntermediateCASubject) {
            $EndPointPublicCertFile = $obj1
            $EndPointSubject = $certPrint.Subject
            $GenerateCertificateFileOutputHashGlobal.Add("EndPointPublicCertFile", "$EndPointPublicCertFile")
        }
    }
    #>

    $GenerateCertificateFileOutputHashGlobal.Add("EndPointProtectedPrivateKey", "$ProtectedPrivateKeyOut")
}
if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y") {
    $GenerateCertificateFileOutputHashGlobal.Add("EndPointUnProtectedPrivateKey", "$UnProtectedPrivateKeyOut")

    # Add UnProtected Private Key to $CertNamevsContentsHashGlobal
    $UnProtectedPrivateKeyContent = ((Get-Content $CertGenWorking\$UnProtectedPrivateKeyOut) -join "`n").Trim()
    $CertNamevsContentsHashGlobal.Add("EndPointUnProtectedPrivateKey", "$UnProtectedPrivateKeyContent")
}

# Return PSObject that contains $GenerateCertificateFileOutputHashGlobal and $CertNamevsContentsHashGlobal HashTables
New-Variable -Name "GenCertOutput" -Scope Script -Value $(
    New-Object PSObject -Property @{
        GenerateCertificateFileOutputHashGlobal    = $GenerateCertificateFileOutputHashGlobal
        CertNamevsContentsHashGlobal               = $CertNamevsContentsHashGlobal
    }
)

# Write the two Global Output HashTableses to STDOUT for Awareness
Write-Host "The `$GenCertOutput PSObject containing `$GenCertOutput.GenerateCertificateFileOutputHashGlobal and `$GenCertOutput.CertNamevsContentsHashGlobal `
for $CertificateCN should now be available in the current scope as a result of the Generate-Certificate function"

$global:FunctionResult = "0"

# ***IMPORTANT NOTE: If you want to write the Certificates contained in the $CertNamevsContentsHashGlobal out to files again
# at some point in the future, make sure you use the "Out-File" cmdlet instead of the "Set-Content" cmdlet

##### END Generate Certificate Request and Submit to Issuing Certificate Authority #####

}

# Generate-Certificate

# SIG # Begin signature block
# MIIMLAYJKoZIhvcNAQcCoIIMHTCCDBkCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQU9n4vkYstxm2d2srmogFrY2Fs
# gGKgggmhMIID/jCCAuagAwIBAgITawAAAAQpgJFit9ZYVQAAAAAABDANBgkqhkiG
# 9w0BAQsFADAwMQwwCgYDVQQGEwNMQUIxDTALBgNVBAoTBFpFUk8xETAPBgNVBAMT
# CFplcm9EQzAxMB4XDTE1MDkwOTA5NTAyNFoXDTE3MDkwOTEwMDAyNFowPTETMBEG
# CgmSJomT8ixkARkWA0xBQjEUMBIGCgmSJomT8ixkARkWBFpFUk8xEDAOBgNVBAMT
# B1plcm9TQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCmRIzy6nwK
# uqvhoz297kYdDXs2Wom5QCxzN9KiqAW0VaVTo1eW1ZbwZo13Qxe+6qsIJV2uUuu/
# 3jNG1YRGrZSHuwheau17K9C/RZsuzKu93O02d7zv2mfBfGMJaJx8EM4EQ8rfn9E+
# yzLsh65bWmLlbH5OVA0943qNAAJKwrgY9cpfDhOWiYLirAnMgzhQd3+DGl7X79aJ
# h7GdVJQ/qEZ6j0/9bTc7ubvLMcJhJCnBZaFyXmoGfoOO6HW1GcuEUwIq67hT1rI3
# oPx6GtFfhCqyevYtFJ0Typ40Ng7U73F2hQfsW+VPnbRJI4wSgigCHFaaw38bG4MH
# Nr0yJDM0G8XhAgMBAAGjggECMIH/MBAGCSsGAQQBgjcVAQQDAgEAMB0GA1UdDgQW
# BBQ4uUFq5iV2t7PneWtOJALUX3gTcTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMA
# QTAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBR2
# lbqmEvZFA0XsBkGBBXi2Cvs4TTAxBgNVHR8EKjAoMCagJKAihiBodHRwOi8vcGtp
# L2NlcnRkYXRhL1plcm9EQzAxLmNybDA8BggrBgEFBQcBAQQwMC4wLAYIKwYBBQUH
# MAKGIGh0dHA6Ly9wa2kvY2VydGRhdGEvWmVyb0RDMDEuY3J0MA0GCSqGSIb3DQEB
# CwUAA4IBAQAUFYmOmjvbp3goa3y95eKMDVxA6xdwhf6GrIZoAg0LM+9f8zQOhEK9
# I7n1WbUocOVAoP7OnZZKB+Cx6y6Ek5Q8PeezoWm5oPg9XUniy5bFPyl0CqSaNWUZ
# /zC1BE4HBFF55YM0724nBtNYUMJ93oW/UxsWL701c3ZuyxBhrxtlk9TYIttyuGJI
# JtbuFlco7veXEPfHibzE+JYc1MoGF/whz6l7bC8XbgyDprU1JS538gbgPBir4RPw
# dFydubWuhaVzRlU3wedYMsZ4iejV2xsf8MHF/EHyc/Ft0UnvcxBqD0sQQVkOS82X
# +IByWP0uDQ2zOA1L032uFHHA65Bt32w8MIIFmzCCBIOgAwIBAgITWAAAADw2o858
# ZSLnRQAAAAAAPDANBgkqhkiG9w0BAQsFADA9MRMwEQYKCZImiZPyLGQBGRYDTEFC
# MRQwEgYKCZImiZPyLGQBGRYEWkVSTzEQMA4GA1UEAxMHWmVyb1NDQTAeFw0xNTEw
# MjcxMzM1MDFaFw0xNzA5MDkxMDAwMjRaMD4xCzAJBgNVBAYTAlVTMQswCQYDVQQI
# EwJWQTEPMA0GA1UEBxMGTWNMZWFuMREwDwYDVQQDEwhaZXJvQ29kZTCCASIwDQYJ
# KoZIhvcNAQEBBQADggEPADCCAQoCggEBAJ8LM3f3308MLwBHi99dvOQqGsLeC11p
# usrqMgmEgv9FHsYv+IIrW/2/QyBXVbAaQAt96Tod/CtHsz77L3F0SLuQjIFNb522
# sSPAfDoDpsrUnZYVB/PTGNDsAs1SZhI1kTKIjf5xShrWxo0EbDG5+pnu5QHu+EY6
# irn6C1FHhOilCcwInmNt78Wbm3UcXtoxjeUl+HlrAOxG130MmZYWNvJ71jfsb6lS
# FFE6VXqJ6/V78LIoEg5lWkuNc+XpbYk47Zog+pYvJf7zOric5VpnKMK8EdJj6Dze
# 4tJ51tDoo7pYDEUJMfFMwNOO1Ij4nL7WAz6bO59suqf5cxQGd5KDJ1ECAwEAAaOC
# ApEwggKNMA4GA1UdDwEB/wQEAwIHgDA9BgkrBgEEAYI3FQcEMDAuBiYrBgEEAYI3
# FQiDuPQ/hJvyeYPxjziDsLcyhtHNeIEnofPMH4/ZVQIBZAIBBTAdBgNVHQ4EFgQU
# a5b4DOy+EUyy2ILzpUFMmuyew40wHwYDVR0jBBgwFoAUOLlBauYldrez53lrTiQC
# 1F94E3EwgeMGA1UdHwSB2zCB2DCB1aCB0qCBz4aBq2xkYXA6Ly8vQ049WmVyb1ND
# QSxDTj1aZXJvU0NBLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxD
# Tj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPXplcm8sREM9bGFiP2NlcnRp
# ZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RDbGFzcz1jUkxEaXN0cmli
# dXRpb25Qb2ludIYfaHR0cDovL3BraS9jZXJ0ZGF0YS9aZXJvU0NBLmNybDCB4wYI
# KwYBBQUHAQEEgdYwgdMwgaMGCCsGAQUFBzAChoGWbGRhcDovLy9DTj1aZXJvU0NB
# LENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxD
# Tj1Db25maWd1cmF0aW9uLERDPXplcm8sREM9bGFiP2NBQ2VydGlmaWNhdGU/YmFz
# ZT9vYmplY3RDbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MCsGCCsGAQUFBzAC
# hh9odHRwOi8vcGtpL2NlcnRkYXRhL1plcm9TQ0EuY3J0MBMGA1UdJQQMMAoGCCsG
# AQUFBwMDMBsGCSsGAQQBgjcVCgQOMAwwCgYIKwYBBQUHAwMwDQYJKoZIhvcNAQEL
# BQADggEBACbc1NDl3NTMuqFwTFd8NHHCsSudkVhuroySobzUaFJN2XHbdDkzquFF
# 6f7KFWjqR3VN7RAi8arW8zESCKovPolltpp3Qu58v59qZLhbXnQmgelpA620bP75
# zv8xVxB9/xmmpOHNkM6qsye4IJur/JwhoHLGqCRwU2hxP1pu62NUK2vd/Ibm8c6w
# PZoB0BcC7SETNB8x2uKzJ2MyAIuyN0Uy/mGDeLyz9cSboKoG6aQibnjCnGAVOVn6
# J7bvYWJsGu7HukMoTAIqC6oMGerNakhOCgrhU7m+cERPkTcADVH/PWhy+FJWd2px
# ViKcyzWQSyX93PcOj2SsHvi7vEAfCGcxggH1MIIB8QIBATBUMD0xEzARBgoJkiaJ
# k/IsZAEZFgNMQUIxFDASBgoJkiaJk/IsZAEZFgRaRVJPMRAwDgYDVQQDEwdaZXJv
# U0NBAhNYAAAAPDajznxlIudFAAAAAAA8MAkGBSsOAwIaBQCgeDAYBgorBgEEAYI3
# AgEMMQowCKACgAChAoAAMBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwGCisG
# AQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMCMGCSqGSIb3DQEJBDEWBBQrQRF3pX4N
# 8ZYEmZy9SUIy0khGgjANBgkqhkiG9w0BAQEFAASCAQCOYibqcQ7nlQ/lUDJg6e9C
# tchm4DkjKIt9JtxF/qxXh2hGKNnnCHS62Jd0KeXhi8W/neDbbwztWT3BtUXf8Ig4
# +9xj6YcSGMDgOf/tog5WA3yBinAlVbAp0UhwhWMtGrOtsSR+L3dTs/5CoJGx72jk
# PWfZeropxHvy8MW40CWuGnLz46PlYmE8o3n56jAlN+Fta32r2Y4m4/T/RPyotSKM
# QVF/i8ZQMQrW/yt+zthbIDc8Dd8EUGBpijS0bJMNDcvZWBGH7lW5+++fim2RPVpr
# ggQ7cdQVzYBO93YpasjaHslpqWgDqHWSdOMAm6OJd84OpgKTclDSID86B625PQCf
# SIG # End signature block
